#!/bin/bash
# ===----------------------------------------===
#      Enhanced Permissions Facilitator v3.0
# ===----------------------------------------===
# Author: ShadowHarvy (Enhanced by AI Assistant)
# Version: 3.0 (The Enhanced Experience)
#
# Purpose: An enhanced helper script to manage device permissions
#          with auto-discovery, status checking, and multiple
#          entertaining personalities.
#
# Usage:
#   dial [options]
#
# Options:
#   -p <persona>   Choose personality: wizard, glados, dm, sassy, sarcastic
#   -d <device>    Specify device file (e.g., /dev/ttyS0)
#   -s, --scan     Scan for available devices
#   -c, --check    Check current group memberships
#   -l, --list     List available devices
#   -n, --dry-run  Show what would happen without making changes
#   -v, --verbose  Enable verbose output
#   -h, --help     Show this help message

# --- Strict Mode & Safety First ---
set -euo pipefail

# --- Configuration ---
DEFAULT_DEVICE="/dev/ttyACM0"
CONFIG_DIR="$HOME/.config/dial"
CONFIG_FILE="$CONFIG_DIR/config.ini"
LOG_DIR="$HOME/.local/share/dial"
LOG_FILE="$LOG_DIR/history.log"

# Device categories for auto-discovery
declare -A DEVICE_CATEGORIES=(
    ["serial"]="/dev/ttyACM* /dev/ttyUSB* /dev/ttyS*"
    ["video"]="/dev/video* /dev/dri/card*"
    ["audio"]="/dev/snd/* /dev/audio*"
    ["usb"]="/dev/bus/usb/*/*"
    ["storage"]="/dev/sd* /dev/nvme*"
)

# --- Global Variables ---
DRY_RUN=false
VERBOSE=false
SCAN_MODE=false
CHECK_MODE=false
LIST_MODE=false

# --- Colors & Styles ---
if [ -t 1 ]; then
  C_RESET='\033[0m' C_BOLD='\033[1m' C_RED='\033[0;31m' C_GREEN='\033[0;32m'
  C_YELLOW='\033[0;33m' C_BLUE='\033[0;34m' C_PURPLE='\033[0;35m' C_CYAN='\033[0;36m'
else
  C_RESET='' C_BOLD='' C_RED='' C_GREEN='' C_YELLOW='' C_BLUE='' C_PURPLE='' C_CYAN=''
fi

# --- Utility Functions ---

# Create necessary directories
setup_directories() {
    [ ! -d "$CONFIG_DIR" ] && mkdir -p "$CONFIG_DIR"
    [ ! -d "$LOG_DIR" ] && mkdir -p "$LOG_DIR"
}

# Logging function
log_operation() {
    local operation="$1"
    local device="$2"
    local group="$3"
    local status="$4"
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    setup_directories
    echo "[$timestamp] $operation: device=$device, group=$group, status=$status" >> "$LOG_FILE"
}

# Verbose output
vlog() {
    [ "$VERBOSE" = true ] && printf "${C_BLUE}[VERBOSE]${C_RESET} %s\n" "$*"
}

# Check if user is already in a group
is_user_in_group() {
    local user="$1"
    local group="$2"
    id -nG "$user" | grep -qw "$group"
}

# Get device info
get_device_info() {
    local device="$1"
    if [ -e "$device" ]; then
        ls -l "$device" | awk '{print $3 ":" $4}'
    else
        echo "not_found:not_found"
    fi
}

# Scan for devices in categories
scan_devices() {
    local category="$1"
    local patterns
    
    if [ -n "$category" ] && [ -n "${DEVICE_CATEGORIES[$category]:-}" ]; then
        patterns="${DEVICE_CATEGORIES[$category]}"
    else
        patterns=""
        for cat_patterns in "${DEVICE_CATEGORIES[@]}"; do
            patterns="$patterns $cat_patterns"
        done
    fi
    
    vlog "Scanning devices with patterns: $patterns"
    
    for pattern in $patterns; do
        # Use find to handle the glob patterns safely
        find "$(dirname "$pattern")" -maxdepth 1 -name "$(basename "$pattern")" 2>/dev/null | sort
    done | sort -u
}

# Find available devices and suggest alternatives
find_device_suggestions() {
    local suggested_device="$1"
    
    printf "\n${C_YELLOW}Available devices that might work:${C_RESET}\n"
    
    local found_any=false
    
    # Check each category
    for category in "${!DEVICE_CATEGORIES[@]}"; do
        local devices
        devices=$(scan_devices "$category")
        if [ -n "$devices" ]; then
            printf "\n  ${C_CYAN}%s devices:${C_RESET}\n" "$category"
            while IFS= read -r device; do
                if [ -n "$device" ]; then
                    local info
                    info=$(get_device_info "$device")
                    local owner group
                    owner=$(echo "$info" | cut -d: -f1)
                    group=$(echo "$info" | cut -d: -f2)
                    printf "    %s (owner: %s, group: %s)\n" "$device" "$owner" "$group"
                    found_any=true
                fi
            done <<< "$devices"
        fi
    done
    
    if [ "$found_any" = false ]; then
        printf "  ${C_YELLOW}No accessible devices found in common categories.${C_RESET}\n"
        printf "  ${C_YELLOW}Try connecting your device and running with -s to scan.${C_RESET}\n"
    fi
    
    printf "\n${C_CYAN}Usage examples:${C_RESET}\n"
    printf "  dial -d /dev/ttyACM0    # Specific device\n"
    printf "  dial -s                 # Scan and choose\n"
    printf "  dial -l                 # List all devices\n"
}

# Show current group memberships
show_current_groups() {
    local user="$1"
    printf "\n${C_CYAN}Current groups for user '%s':${C_RESET}\n" "$user"
    id -nG "$user" | tr ' ' '\n' | sort | while read -r group; do
        printf "  - %s\n" "$group"
    done
    printf "\n"
}

# --- Global State & Persona Text ---
declare -A TEXT # This will hold the text for the chosen persona

# --- Functions ---

print_usage() {
  cat <<EOF
Usage: $0 [options]

The Enhanced Permissions Facilitator v3.0

Manage device permissions with style and personality.

Options:
  -p <persona>   Choose personality: wizard, glados, dm, sassy, sarcastic
                 If omitted, a random one is chosen.
  -d <device>    Specify device file (e.g., /dev/ttyACM0)
                 Defaults to "$DEFAULT_DEVICE"
  -s, --scan     Interactive device scanning and selection
  -c, --check    Show current group memberships and exit
  -l, --list     List all available devices and exit
  -n, --dry-run  Show what would happen without making changes
  -v, --verbose  Enable verbose output for debugging
  -h, --help     Show this help message and exit

Examples:
  $0                          # Use default device with random personality
  $0 -p wizard -d /dev/video0 # Specific device with wizard personality
  $0 -s                       # Scan and choose device interactively
  $0 -c                       # Check current group memberships
  $0 -n -d /dev/ttyUSB0       # Dry run to see what would happen
EOF
}

# Loads the text strings for the selected personality.
setup_persona() {
  local choice="${1:-}"
  local personas=("wizard" "glados" "dm" "sassy" "sarcastic")

  if [ -z "$choice" ]; then
    choice=${personas[$((RANDOM % ${#personas[@]}))]}
    printf "${C_YELLOW}No persona specified. The fates have chosen: ${C_BOLD}%s${C_RESET}\n" "$choice"
    sleep 1
  fi

  # --- Persona Text Definitions ---
  declare -A WIZARD_TEXT=(
    [title]="The Oracle of Device Access"
    [author]="A spell by: ShadowHarvy"
    [welcome]="Welcome, seeker. You require access to a sacred artifact, do you not?"
    [analyzing]="Let us consult the system's arcane energies for device '%s'..."
    [device_not_found]="The artifact '%s' cannot be found in this realm. Is it properly connected?"
    [device_found]="The artifact '%s' has been detected."
    [finding_group]="Scrying for the guardian group of the artifact..."
    [group_found]="The guardian group is revealed to be '%s'."
    [user_is]="You are known to the spirits as '%s'."
    [initiating_ritual]="We shall now perform the Ritual of Access for user '%s' to group '%s'."
    [sudo_prompt]="This ritual requires great power. Prepare to invoke 'sudo'."
    [confirm_prompt]="Shall we proceed with the ritual? (y/n): "
    [cancelled]="The ritual is aborted. The spirits are displeased."
    [success]="Success! User '%s' has joined the '%s' fellowship."
    [logout_notice]="You must rest and meditate (log out and back in) for the changes to be recognized by the spirits."
    [failure]="The ritual failed. The arcane energies are in turmoil."
    [conclusion]="The Oracle has spoken. Go now, and create wonders."
    [already_member]="The spirits whisper that you are already a member of the '%s' fellowship."
    [scanning_realm]="Scanning the mystical realm for available artifacts..."
    [dry_run]="The Oracle peers into possible futures without disturbing the present..."
    [checking_fellowship]="Consulting the ancient scrolls of your current fellowships..."
    [no_change_needed]="The cosmic balance is already perfect. No changes are required."
  )

  declare -A GLADOS_TEXT=(
    [title]="Aperture Science Permissions Facilitator"
    [author]="Mandated Acknowledgment: Conceived by ShadowHarvy"
    [welcome]="Oh, look. Another test subject... I mean, *user*... requires access adjustments."
    [analyzing]="Right. Let's analyze your... *quaint*... security configuration for device '%s'."
    [device_not_found]="Error: Device '%s' not found. Did you forget to plug it in? Or perhaps it simply doesn't *like* you."
    [device_found]="Device '%s' detected. Minimal compliance noted."
    [finding_group]="Executing primitive command to determine group ownership..."
    [group_found]="Analysis complete. The group with access privileges is: '%s'."
    [user_is]="Your user account is: '%s'."
    [initiating_ritual]="Now, initiating the procedure to grant '%s' access to group '%s'."
    [sudo_prompt]="This requires elevated privileges. Prepare for the 'sudo' prompt. Don't mess it up."
    [confirm_prompt]="Proceed? (y/N): "
    [cancelled]="Procedure aborted by user. Cowardice noted in your permanent record."
    [success]="Success. User '%s' has been added to group '%s'. Try not to break anything."
    [logout_notice]="Important: The system changes require you to log out and log back in, or reboot. Do it now."
    [failure]="Operation Failed. Perhaps you mistyped your password? Or maybe the system decided you are... *unworthy*."
    [conclusion]="This concludes the assistance protocol. I'll be watching."
    [already_member]="Interesting. You're already in group '%s'. Did you forget, or are you just testing me?"
    [scanning_realm]="Scanning available test chambers... I mean, devices... for experimentation purposes."
    [dry_run]="Running simulation mode. No actual changes will be made. How disappointingly safe."
    [checking_fellowship]="Retrieving your current test group assignments from the database..."
    [no_change_needed]="No action required. The system is already perfectly configured. Unlike your judgment."
  )

  declare -A DM_TEXT=(
    [title]="The Guild of Device Access"
    [author]="A quest from: ShadowHarvy"
    [welcome]="Greetings, adventurer! You seek to join a new guild, I see."
    [analyzing]="Let's check the guild charter for the device at '%s'..."
    [device_not_found]="Alas, the device '%s' cannot be found. Have you brought it with you on your travels?"
    [device_found]="The device '%s' is present and accounted for."
    [finding_group]="Identifying the guild that protects this device..."
    [group_found]="The device is protected by the '%s' guild."
    [user_is]="You are known in these lands as '%s'."
    [initiating_ritual]="We shall now petition for '%s' to join the '%s' guild."
    [sudo_prompt]="This requires a royal decree. You must present your 'sudo' credentials."
    [confirm_prompt]="Are you ready to pledge your allegiance? (y/n): "
    [cancelled]="You have withdrawn your petition. The guild master is disappointed."
    [success]="Congratulations! User '%s' is now a member of the '%s' guild."
    [logout_notice]="You must leave the tavern and return (log out and back in) for your new membership to be recognized."
    [failure]="Your petition has failed. The royal court is not convinced of your worthiness."
    [conclusion]="Your guild business is concluded. Go forth on your next adventure!"
  )

  declare -A SASSY_TEXT=(
    [title]="The 'Just Give Me Access' Utility"
    [author]="By: Someone who has better things to do."
    [welcome]="Okay, let's sort out your permissions. This shouldn't take long. Unless you mess it up."
    [analyzing]="Looking for your little device at '%s'. Hope it's actually there."
    [device_not_found]="And it's not there. Shocker. Did you even plug it in?"
    [device_found]="Found '%s'. See? Not that hard."
    [finding_group]="Figuring out which group owns this thing..."
    [group_found]="Okay, the group is '%s'."
    [user_is]="And you are, apparently, '%s'."
    [initiating_ritual]="Right, let's add '%s' to the '%s' group. Finally."
    [sudo_prompt]="You'll need to use 'sudo'. Try to type your password correctly the first time."
    [confirm_prompt]="Are we doing this or what? (y/n): "
    [cancelled]="Fine, be that way. Your loss."
    [success]="There. You're in. User '%s' is now in group '%s'."
    [logout_notice]="Now, you have to log out and back in for this to work. Yes, really."
    [failure]="It failed. I'm not surprised. Check the error, I guess."
    [conclusion]="Done. Now if you'll excuse me, I have actual work to do."
  )

  declare -A SARCASTIC_TEXT=(
    [title]="The 'Why Isn't This Working?' Fixer"
    [author]="Because reading the manual is for other people."
    [welcome]="Oh, you can't access a device? How completely unexpected. Let's see what's wrong."
    [analyzing]="Searching for the elusive device at '%s'. This is thrilling."
    [device_not_found]="And it's not found. A brilliant start to our journey."
    [device_found]="What do you know, '%s' actually exists. Progress."
    [finding_group]="Determining the group you're supposed to be in..."
    [group_found]="The group is '%s'. Write that down, there might be a test later."
    [user_is]="And you, the user, are '%s'."
    [initiating_ritual]="Now for the incredibly complex task of adding '%s' to the '%s' group."
    [sudo_prompt]="You'll need 'sudo' for this. I trust you remember your own password."
    [confirm_prompt]="Shall we proceed with this monumental task? (y/n): "
    [cancelled]="Aborting. I'm sure you had your reasons."
    [success]="It worked. User '%s' has been added to group '%s'. A true miracle of technology."
    [logout_notice]="Of course, for this to actually take effect, you need to log out and back in. Don't forget that part."
    [failure]="It failed. I'm shocked. Shocked, I tell you. Well, not that shocked."
    [conclusion]="The task is complete. I'm sure everything will work perfectly from now on."
  )

  case "$choice" in
  wizard) for k in "${!WIZARD_TEXT[@]}"; do TEXT["$k"]="${WIZARD_TEXT[$k]}"; done ;;
  glados) for k in "${!GLADOS_TEXT[@]}"; do TEXT["$k"]="${GLADOS_TEXT[$k]}"; done ;;
  dm) for k in "${!DM_TEXT[@]}"; do TEXT["$k"]="${DM_TEXT[$k]}"; done ;;
  sassy) for k in "${!SASSY_TEXT[@]}"; do TEXT["$k"]="${SASSY_TEXT[$k]}"; done ;;
  sarcastic) for k in "${!SARCASTIC_TEXT[@]}"; do TEXT["$k"]="${SARCASTIC_TEXT[$k]}"; done ;;
  *)
    printf "${C_RED}Error: Unknown persona '%s'.${C_RESET}\n" "$choice"
    print_usage
    exit 1
    ;;
  esac
}

# Special modes that don't need personas
handle_special_modes() {
    if [ "$CHECK_MODE" = true ]; then
        printf "${C_PURPLE}=== Current Group Memberships ===${C_RESET}\n"
        show_current_groups "$USER"
        exit 0
    fi
    
    if [ "$LIST_MODE" = true ]; then
        printf "${C_PURPLE}=== Available Devices ===${C_RESET}\n"
        find_device_suggestions ""
        exit 0
    fi
    
    if [ "$SCAN_MODE" = true ]; then
        printf "${C_PURPLE}=== Device Scanner ===${C_RESET}\n"
        printf "${C_YELLOW}Scanning for available devices...${C_RESET}\n\n"
        find_device_suggestions ""
        printf "\n${C_CYAN}Please select a device manually using -d <device>${C_RESET}\n"
        exit 0
    fi
}

# --- Main Execution Logic ---
main() {
  local persona_choice=""
  local device="$DEFAULT_DEVICE"

  # Parse arguments (both short and long options)
  while [[ $# -gt 0 ]]; do
    case $1 in
      -p) persona_choice="$2"; shift 2 ;;
      -d) device="$2"; shift 2 ;;
      -s|--scan) SCAN_MODE=true; shift ;;
      -c|--check) CHECK_MODE=true; shift ;;
      -l|--list) LIST_MODE=true; shift ;;
      -n|--dry-run) DRY_RUN=true; shift ;;
      -v|--verbose) VERBOSE=true; shift ;;
      -h|--help) print_usage; exit 0 ;;
      --) shift; break ;;
      -*) printf "Unknown option: %s\n" "$1" >&2; print_usage; exit 1 ;;
      *) break ;;
    esac
  done

  # Handle special modes first
  handle_special_modes
  
  setup_persona "$persona_choice"

  clear
  cat <<EOF
====================================================================
${C_PURPLE}${TEXT[title]}${C_RESET}
${TEXT[author]}
====================================================================
EOF

  if [ "$DRY_RUN" = true ]; then
    printf "\n${C_YELLOW}[DRY RUN MODE] - No actual changes will be made${C_RESET}\n"
    if [ -n "${TEXT[dry_run]:-}" ]; then
      printf "${C_GREEN}%s${C_RESET}\n\n" "${TEXT[dry_run]}"
    fi
  else
    printf "\n${C_GREEN}%s${C_RESET}\n\n" "${TEXT[welcome]}"
  fi
  sleep 1

  printf -- "-> "
  printf "${TEXT[analyzing]}" "$device"
  printf "\n"

  if [ ! -e "$device" ]; then
    printf "${C_RED}"
    printf "${TEXT[device_not_found]}" "$device"
    printf "${C_RESET}\n" >&2
    
    # Offer suggestions when device not found
    find_device_suggestions "$device"
    exit 1
  fi
  
  vlog "Device found: $device"
  printf "   ${C_GREEN}"
  printf "${TEXT[device_found]}" "$device"
  printf "${C_RESET}\n"

  printf -- "-> "
  printf "${TEXT[finding_group]}"
  printf "\n"

  local DEVICE_GROUP
  DEVICE_GROUP=$(ls -l "$device" | awk '{print $4}')
  
  vlog "Device group: $DEVICE_GROUP"
  printf "   ${C_GREEN}"
  printf "${TEXT[group_found]}" "$DEVICE_GROUP"
  printf "${C_RESET}\n"

  printf "   ${C_GREEN}"
  printf "${TEXT[user_is]}" "$USER"
  printf "${C_RESET}\n"

  # Check if user is already in the group
  if is_user_in_group "$USER" "$DEVICE_GROUP"; then
    printf "\n${C_YELLOW}"
    if [ -n "${TEXT[already_member]:-}" ]; then
      printf "${TEXT[already_member]}" "$DEVICE_GROUP"
    else
      printf "User '%s' is already a member of group '%s'." "$USER" "$DEVICE_GROUP"
    fi
    printf "${C_RESET}\n"
    
    if [ -n "${TEXT[no_change_needed]:-}" ]; then
      printf "\n${C_GREEN}%s${C_RESET}\n" "${TEXT[no_change_needed]}"
    fi
    
    log_operation "check" "$device" "$DEVICE_GROUP" "already_member"
    printf "\n${C_PURPLE}*** "
    printf "${TEXT[conclusion]}"
    printf " ***${C_RESET}\n\n"
    exit 0
  fi

  sleep 1

  printf "\n"
  if [ "$DRY_RUN" = true ]; then
    printf "${C_YELLOW}[DRY RUN]${C_RESET} Would add user '%s' to group '%s'\n" "$USER" "$DEVICE_GROUP"
    log_operation "dry_run" "$device" "$DEVICE_GROUP" "simulated"
  else
    printf "${TEXT[initiating_ritual]}" "$USER" "$DEVICE_GROUP"
    printf "\n"
    printf "${C_YELLOW}%s${C_RESET}\n" "${TEXT[sudo_prompt]}"

    local CONFIRM
    read -rp "$(printf "${TEXT[confirm_prompt]}")" CONFIRM
    if [[ "$CONFIRM" != "y" && "$CONFIRM" != "Y" ]]; then
      printf "\n${C_YELLOW}%s${C_RESET}\n" "${TEXT[cancelled]}"
      log_operation "add_to_group" "$device" "$DEVICE_GROUP" "cancelled"
      exit 0
    fi

    printf "\n"
    vlog "Executing: sudo usermod -a -G $DEVICE_GROUP $USER"
    sudo usermod -a -G "$DEVICE_GROUP" "$USER"
    local EXIT_STATUS=$?

    if [ $EXIT_STATUS -eq 0 ]; then
      printf "\n${C_GREEN}"
      printf "${TEXT[success]}" "$USER" "$DEVICE_GROUP"
      printf "${C_RESET}\n"
      printf "\n${C_YELLOW}%s${C_RESET}\n" "${TEXT[logout_notice]}"
      log_operation "add_to_group" "$device" "$DEVICE_GROUP" "success"
    else
      printf "\n${C_RED}"
      printf "${TEXT[failure]}"
      printf "${C_RESET}\n"
      log_operation "add_to_group" "$device" "$DEVICE_GROUP" "failed"
    fi
  fi

  printf "\n${C_PURPLE}*** "
  printf "${TEXT[conclusion]}"
  printf " ***${C_RESET}\n\n"
}

# --- Script Entry Point ---
main "$@"

exit 0
