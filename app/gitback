#!/bin/bash
# ===--------------------------------------------------===
#     The Grand Repo Wrangler & Backupinator 9001
# ===--------------------------------------------------===
# Author: ShadowHarvy (The Git Whisperer)
# Version: 3.4 (Community Fix Edition)
#
# Purpose: Scours configured realms for git repositories,
#          bravely attempts to update them, and meticulously
#          scribes their details onto a backup scroll.
#          Now with selectable personalities for varied flavor!
#
# Usage:
#   ./repo_manager_script_v4.sh [options]
#
# Options:
#   -p <persona>  Choose a personality: wizard, glados, dm.
#                 If omitted, a random one is chosen.
#   -h            Show this help message.

# --- Strict Mode & Safety First ---
set -euo pipefail

# --- Configuration ---
SEARCH_DIRS=(
  "$HOME/git"
  "$HOME/development"
)
BACKUP_DIR="$HOME/backup"
BACKUP_FILE="$BACKUP_DIR/repo_backup.txt"
SKIP_THEATRICS=0
INTER_REPO_DELAY=0.2

# --- Colors & Styles ---
if [ -t 1 ]; then
  C_RESET='\033[0m' C_BOLD='\033[1m' C_RED='\033[0;31m' C_GREEN='\033[0;32m'
  C_YELLOW='\033[0;33m' C_BLUE='\033[0;34m' C_PURPLE='\033[0;35m' C_CYAN='\033[0;36m'
else
  C_RESET='' C_BOLD='' C_RED='' C_GREEN='' C_YELLOW='' C_BLUE='' C_PURPLE='' C_CYAN=''
fi

# --- Global State & Persona Text ---
declare -A SCROLL_ENTRIES
declare -A TEXT # This will hold the text for the chosen persona
REPOS_NEWLY_ADDED=0
REPOS_WITH_UPDATES=0
repo_count=0
skipped_count=0

# --- Functions ---

print_usage() {
  cat <<EOF
Usage: $0 [options]

The Grand Repo Wrangler & Backupinator 9001

Options:
  -p <persona>  Choose a personality. Available: wizard, glados, dm.
                If this option is omitted, a random one is chosen.
  -h            Show this help message and exit.
EOF
}

# Loads the text strings for the selected personality.
setup_persona() {
  local choice="${1:-}"
  local personas=("wizard" "glados" "dm")

  if [ -z "$choice" ]; then
    # Choose a random persona if none is specified
    choice=${personas[$((RANDOM % ${#personas[@]}))]}
    printf "${C_YELLOW}No persona specified. The fates have chosen: ${C_BOLD}%s${C_RESET}\n" "$choice"
    sleep 1
  fi

  # --- Persona Text Definitions ---

  # Default: The Original Git Wizard
  declare -A WIZARD_TEXT=(
    [title]="The Grand Repo Wrangler & Backupinator 9001"
    [author]="Created by: ShadowHarvy"
    [intro_start]="Powering up the Repo Wrangler"
    [intro_online]="Powering up the Repo Wrangler... ONLINE!"
    [intro_scan]="Scanning known dimensions for git traces..."
    [intro_scroll]="Consulting the sacred backup scroll's history..."
    [intro_commence]="Let the wrangling commence!"
    [corral_setup]="Setting Up The Corral & Checking Scroll History"
    [scouring_dim]="Now scouring the '%s' dimension (%s)..."
    [no_repos_found]="Found no git repositories in '%s'. How tidy. Or empty."
    [repo_found]="Found Repo #%s: '%s'"
    [remote_url]="Remote 'origin' URL: %s"
    [new_inscription]="New inscription for the scroll: '%s'."
    [known_to_scroll]="Already known to the scroll."
    [update_attempt]="Attempting tactical update (fetch & check)..."
    [fetch_fail]="'git fetch' for '%s' failed. Check manually!"
    [behind_remote]="Branch is behind remote. Pulling changes..."
    [pull_success]="âœ” Successfully pulled new changes."
    [pull_fail]="!! ERROR: 'git pull' failed. Merge conflict or other issue?"
    [ahead_remote]="Branch is ahead of remote. No pull needed."
    [up_to_date]="âœ” Already up-to-date."
    [diverged]="!! WARNING: Branch has diverged. Manual intervention required."
    [no_tracking]="No tracking info, or other status. Skipping pull."
    [finalizing_scroll]="Finalizing The Sacred Scroll"
    [inscribing_lore]="Inscribing all collected lore onto %s"
    [report_header]="Wrangling Report (Run: $(date))"
    [mission_accomplished]="Mission accomplished! Go forth and code! ðŸ˜Ž"
  )

  # GLaDOS: Sarcastic AI
  declare -A GLADOS_TEXT=(
    [title]="Aperture Science Collaborative Work Monitoring System"
    [author]="Now with 80% less spontaneous combustion."
    [intro_start]="Initiating Surprise Compliance Test"
    [intro_online]="Compliance testing protocols... ACTIVE."
    [intro_scan]="Scanning test chambers for unauthorized projects..."
    [intro_scroll]="Reviewing your... permanent record."
    [intro_commence]="Let the 'testing' begin. For science."
    [corral_setup]="Calibrating Test Environment"
    [scouring_dim]="Analyzing sector '%s' (%s)..."
    [no_repos_found]="Sector '%s' is clean. Suspiciously clean."
    [repo_found]="Test Subject #%s located: '%s'"
    [remote_url]="Central repository link established: %s"
    [new_inscription]="A new variable has been added to your test profile: '%s'."
    [known_to_scroll]="This variable is already noted in your file."
    [update_attempt]="Attempting mandatory synchronization..."
    [fetch_fail]="Synchronization failed for '%s'. A note has been made of your failure."
    [behind_remote]="Your work is outdated. Initiating corrective synchronization..."
    [pull_success]="âœ” Synchronization complete. All your work now belongs to us."
    [pull_fail]="!! ERROR: Synchronization conflict. You broke it, didn't you?"
    [ahead_remote]="You have unsubmitted work. This is... inefficient."
    [up_to_date]="âœ” Your work is compliant with the central repository. For now."
    [diverged]="!! WARNING: You have deviated from testing parameters. This is being recorded."
    [no_tracking]="This project is not registered. A demerit has been issued."
    [finalizing_scroll]="Finalizing Your Performance Review"
    [inscribing_lore]="Archiving test results to %s"
    [report_header]="Mandatory Performance Review (Date: $(date))"
    [mission_accomplished]="The test is complete. You may now resume your pointless activities. The cake is a lie."
  )

  # Dungeon Master: Epic Narrator
  declare -A DM_TEXT=(
    [title]="Tome of the Git-Scryer"
    [author]="Chronicled by: The Dungeon Master"
    [intro_start]="The party gathers at the terminal"
    [intro_online]="The terminal glows with arcane energy... READY!"
    [intro_scan]="Scrying the digital planes for ancient sigils..."
    [intro_scroll]="Consulting the ancient scrolls of backup..."
    [intro_commence]="Let the adventure begin!"
    [corral_setup]="Preparing The Quest Board & Reviewing Old Maps"
    [scouring_dim]="You enter the '%s' dungeon, a maze of directories (%s)..."
    [no_repos_found]="The '%s' dungeon is empty. You find no treasure here."
    [repo_found]="A glint of magic! You've found Artifact #%s: '%s'"
    [remote_url]="It resonates with a distant source: %s"
    [new_inscription]="You transcribe the artifact's sigil to your map: '%s'."
    [known_to_scroll]="This artifact is already marked on your map."
    [update_attempt]="You attempt to channel energy from the remote source..."
    [fetch_fail]="Your connection to the source is blocked for '%s'!"
    [behind_remote]="The source holds new knowledge. You begin the ritual of pulling..."
    [pull_success]="âœ” The ritual is a success! New lore has been absorbed."
    [pull_fail]="!! The ritual fails! A wave of chaotic energy erupts."
    [ahead_remote]="Your knowledge surpasses the source. No ritual is needed."
    [up_to_date]="âœ” Your knowledge is in harmony with the source."
    [diverged]="!! Your lore and the source's have diverged! A paradox is imminent."
    [no_tracking]="This artifact has no connection to a remote source."
    [finalizing_scroll]="Binding The Final Chronicle"
    [inscribing_lore]="Inscribing the session's tales onto the scroll at %s"
    [report_header]="Tale of the Session (Recorded: $(date))"
    [mission_accomplished]="Your quest is complete! Rest now, for more adventures await at dawn."
  )

  case "$choice" in
    wizard) for k in "${!WIZARD_TEXT[@]}"; do TEXT["$k"]="${WIZARD_TEXT[$k]}"; done ;;
    glados) for k in "${!GLADOS_TEXT[@]}"; do TEXT["$k"]="${GLADOS_TEXT[$k]}"; done ;;
    dm) for k in "${!DM_TEXT[@]}"; do TEXT["$k"]="${DM_TEXT[$k]}"; done ;;
    *)
      printf "${C_RED}Error: Unknown persona '%s'.${C_RESET}\n" "$choice"
      print_usage
      exit 1
      ;;
  esac
}

print_header() {
  printf "\n${C_BOLD}${C_PURPLE}---=== %s ===---${C_RESET}\n" "$1"
}

initial_loader() {
  if [ "$SKIP_THEATRICS" -eq 1 ]; then return; fi
  printf "\n"
  local spinner=('âš™ï¸   ' 'âš™ï¸âš™ï¸  ' 'âš™ï¸âš™ï¸âš™ï¸ ' ' âš™ï¸âš™ï¸âš™ï¸' '  âš™ï¸âš™ï¸âš™ï¸' '   âš™ï¸âš™ï¸' '    âš™ï¸' '     ')
  for i in {1..20}; do
    printf "\r ${C_CYAN}[*] %s ${spinner[i % ${#spinner[@]}]}${C_RESET}" "${TEXT[intro_start]}"
    sleep 0.2
  done
  printf "\r ${C_GREEN}[*] %s      ${C_RESET}\n\n" "${TEXT[intro_online]}"
  printf " ${C_CYAN}[*] %s${C_RESET}\n" "${TEXT[intro_scan]}"
  sleep 0.7
  printf " ${C_CYAN}[*] %s${C_RESET}\n" "${TEXT[intro_scroll]}"
  sleep 0.8
  printf " ${C_GREEN}[*] %s${C_RESET}\n" "${TEXT[intro_commence]}"
  sleep 0.5
}

process_repositories_in_dir() {
  local target_dir="$1"
  local dir_name
  dir_name=$(basename "$target_dir")

  printf "\n${C_BOLD}"
  printf "${TEXT[scouring_dim]}" "$dir_name" "$target_dir"
  printf "${C_RESET}\n"

  local find_output
  find_output=$(find "$target_dir" -maxdepth 2 -name ".git" -type d -prune 2>/dev/null || true)

  if [ -z "$find_output" ]; then
    printf "   -> "
    printf "${TEXT[no_repos_found]}" "$dir_name"
    printf "\n"
    return
  fi

  while IFS= read -r git_dir_path; do
    local repo_dir
    repo_dir="$(dirname "$git_dir_path")"
    local repo_basename
    repo_basename=$(basename "$repo_dir")
    repo_count=$((repo_count + 1))

    printf "\n${C_CYAN}  -> "
    printf "${TEXT[repo_found]}" "$repo_count" "$repo_basename"
    printf "${C_RESET}\n"

    if ! pushd "$repo_dir" >/dev/null; then
      printf "  ${C_RED}!! ERROR: Couldn't warp into '%s'. Skipping.${C_RESET}\n" "$repo_dir"
      skipped_count=$((skipped_count + 1))
      continue
    fi

    local repo_url
    repo_url=$(git config --get remote.origin.url || true)

    if [ -z "$repo_url" ]; then
      printf "  ${C_YELLOW}!! WARNING: No remote 'origin' found. Cannot update or reliably back up.${C_RESET}\n"
      skipped_count=$((skipped_count + 1))
    else
      printf "     -> "
      printf "${TEXT[remote_url]}" "$repo_url"
      printf "\n"
      local entry_key="${repo_url},${repo_basename}"

      # === FIX APPLIED HERE ===
      # Use `[[ ! -v ... ]]` to safely check for key existence with `set -u`.
      if [[ ! -v SCROLL_ENTRIES[$entry_key] ]]; then
        printf "     -> ${C_GREEN}"
        printf "${TEXT[new_inscription]}" "$repo_basename"
        printf "${C_RESET}\n"
        SCROLL_ENTRIES["$entry_key"]=1
        REPOS_NEWLY_ADDED=$((REPOS_NEWLY_ADDED + 1))
      else
        printf "     -> %s\n" "${TEXT[known_to_scroll]}"
      fi

      printf "     -> %s\n" "${TEXT[update_attempt]}"
      if ! git fetch --quiet; then
        printf "  ${C_YELLOW}!! WARNING: "
        printf "${TEXT[fetch_fail]}" "$repo_basename"
        printf "${C_RESET}\n"
      else
        local status
        status=$(git status --short --branch)
        # The order is critical: check for the most complex case (diverged) first.
        if [[ "$status" == *"[ahead "*","*" behind "*"]"* ]]; then
            printf "     -> ${C_YELLOW}%s${C_RESET}\n" "${TEXT[diverged]}"
        elif [[ "$status" == *"[behind "*"]"* ]]; then
            printf "     -> %s\n" "${TEXT[behind_remote]}"
            if git pull --quiet; then
            printf "     -> ${C_GREEN}%s${C_RESET}\n" "${TEXT[pull_success]}"
            REPOS_WITH_UPDATES=$((REPOS_WITH_UPDATES + 1))
            else
            printf "     -> ${C_RED}%s${C_RESET}\n" "${TEXT[pull_fail]}"
            fi
        elif [[ "$status" == *"[ahead "*"]"* ]]; then
            printf "     -> %s\n" "${TEXT[ahead_remote]}"
        elif [[ "$status" == *"..."* ]]; then # The "..." indicates a tracking branch is set
            printf "     -> ${C_GREEN}%s${C_RESET}\n" "${TEXT[up_to_date]}"
        else
            printf "     -> %s\n" "${TEXT[no_tracking]}"
        fi
      fi
    fi
    popd >/dev/null
  done < <(echo "$find_output")
}

# --- Main Execution Logic ---
main() {
  local persona_choice=""
  while getopts ":p:h" opt; do
    case $opt in
    p) persona_choice="$OPTARG" ;;
    h)
      print_usage
      exit 0
      ;;
    \?)
      printf "Invalid option: -$OPTARG\n" >&2
      print_usage
      exit 1
      ;;
    esac
  done

  setup_persona "$persona_choice"

  clear
  cat <<EOF
====================================================================
${TEXT[title]}
${TEXT[author]}
====================================================================
EOF

  initial_loader

  print_header "${TEXT[corral_setup]}"
  local made_dir=0
  for dir_to_check in "${SEARCH_DIRS[@]}" "$BACKUP_DIR"; do
    if [ ! -d "$dir_to_check" ]; then
      printf " -> Directory (%s) is missing. Creating it...\n" "$dir_to_check"
      mkdir -p "$dir_to_check"
      made_dir=1
    fi
  done
  if [ $made_dir -eq 0 ]; then
    printf " -> All necessary directories already exist. How organized!\n"
  fi
  local original_conjured_date=""
  if [ -f "$BACKUP_FILE" ]; then
    printf " -> Found existing backup scroll. Reading known lore...\n"
    original_conjured_date=$(grep -m1 "^# Conjured on:" "$BACKUP_FILE" | sed 's/# Conjured on: //' || true)

    local file_content
    file_content=$(grep -v '^#' "$BACKUP_FILE" | grep ',' || true)
    if [ -n "$file_content" ]; then
      while IFS= read -r line; do
        # Ensure we don't process empty lines that might sneak through
        if [ -n "$line" ]; then
          SCROLL_ENTRIES["$line"]=1
        fi
      done <<<"$file_content"
    fi

    printf " -> Found ${C_BOLD}%s${C_RESET} existing entries in the scroll.\n" "${#SCROLL_ENTRIES[@]}"
  else
    printf " -> No ancient scroll detected. A new one shall be conjured!\n"
    original_conjured_date=$(date)
  fi
  printf " -> Scroll consultation complete.\n"

  print_header "${TEXT[intro_commence]}"
  for dir in "${SEARCH_DIRS[@]}"; do
    if [ -d "$dir" ]; then
      process_repositories_in_dir "$dir"
    else
      printf "\n${C_YELLOW} -> Skipping Directory (%s) as it doesn't exist.${C_RESET}\n" "$dir"
    fi
  done

  print_header "${TEXT[finalizing_scroll]}"
  printf " -> "
  printf "${TEXT[inscribing_lore]}" "$BACKUP_FILE"
  printf "\n"

  {
    printf "# === Sacred Repository Backup Scroll ===\n"
    printf "# Conjured on: %s\n" "$original_conjured_date"
    printf "# Last Full Scan: %s\n" "$(date)"
    printf "# Format: repository_url,directory_name\n"
    printf "# This scroll is updated on each run, preserving existing entries.\n\n"
  } >"$BACKUP_FILE"

  if [ ${#SCROLL_ENTRIES[@]} -gt 0 ]; then
    printf "%s\n" "${!SCROLL_ENTRIES[@]}" | sort >>"$BACKUP_FILE"
    printf " -> ${C_GREEN}%s total entries have been inscribed into the scroll.${C_RESET}\n" "${#SCROLL_ENTRIES[@]}"
  else
    printf " -> No entries to inscribe on the scroll.\n"
  fi
  printf " -> Backup scroll updated: ${C_BOLD}%s${C_RESET}\n" "$BACKUP_FILE"

  print_header "${TEXT[report_header]}"
  printf "Summary for this run:\n"
  printf "  - Repositories Found & Processed:     ${C_BOLD}%s${C_RESET}\n" "$repo_count"
  printf "  - Repositories With New Commits:      ${C_BOLD}${C_GREEN}%s${C_RESET}\n" "$REPOS_WITH_UPDATES"
  printf "  - Repositories Newly Added to Scroll: ${C_BOLD}${C_CYAN}%s${C_RESET}\n" "$REPOS_NEWLY_ADDED"
  printf "  - Total Entries Now in Scroll:        ${C_BOLD}%s${C_RESET}\n" "${#SCROLL_ENTRIES[@]}"
  printf "  - Skipped (No remote/CD Errors):      ${C_BOLD}${C_YELLOW}%s${C_RESET}\n" "$skipped_count"
  printf "\n"

  printf "%s\n" "${TEXT[mission_accomplished]}"
  printf "\n"
}

# --- Script Entry Point ---
main "$@"

exit 0