#!/usr/bin/env bash
# ===----------------------------------------===
#            Log Detective 5000‚Ñ¢
# ===----------------------------------------===
# Author: ShadowHarvy (Chief Digital Investigator)
# Version: 1.0 (Elementary, my dear Watson!)
#
# Purpose: Analyzes log files with the precision of Sherlock Holmes
#          and the drama of a crime scene investigation. Because
#          manually grep'ing through logs is for digital peasants.
#
# Usage:
#   logparse [options] <logfile>
#   logparse --errors /var/log/apache2/error.log
#   logparse --ips --top 10 access.log
#   logparse --interactive server.log
#   logparse --json --errors app.log > report.json
#
# Options:
#   -e, --errors         Hunt for errors and warnings
#   -i, --ips           Analyze IP address patterns
#   -p, --performance   Performance metrics (response times)
#   -t, --top N         Show top N results (default: 10)
#   -f, --format TYPE   Specify log format (apache, nginx, json, syslog)
#   -d, --date RANGE    Date range filter (today, yesterday, 2023-01-01)
#   -r, --regex PATTERN Custom regex pattern matching
#   -j, --json          Output results as JSON
#   -c, --csv           Output results as CSV
#   -I, --interactive   Interactive exploration mode
#   -q, --quiet         Less theatrical output
#   -h, --help          Show this help and exit
#   -v, --version       Show version information
#
# Analysis Types:
#   errors    - Find and categorize error messages
#   ips       - Analyze IP addresses and geographic patterns  
#   performance - Response time and performance metrics
#   custom    - Custom regex pattern analysis
#   summary   - Overall log statistics and health check
#
# Exit Codes:
#   0 - Analysis completed successfully
#   1 - No significant findings
#   2 - Invalid arguments or file access issues
#   3 - Parsing errors encountered

# --- Strict Mode & Safety First ---
set -euo pipefail

# --- Script Configuration ---
SCRIPT_VERSION="1.0"
ANALYSIS_TYPE=""
FORMAT_TYPE="auto"
TOP_N=10
DATE_RANGE=""
CUSTOM_REGEX=""
OUTPUT_FORMAT="terminal"
QUIET_MODE=0
INTERACTIVE_MODE=0

# Temporary files for analysis
TMP_DIR="/tmp/logparse_$$"
mkdir -p "$TMP_DIR"
trap 'rm -rf "$TMP_DIR"' EXIT

# --- Colors & Visual Flair ---
if [ -t 1 ]; then
    C_RESET='\033[0m'
    C_BOLD='\033[1m'
    C_DIM='\033[2m'
    C_RED='\033[0;31m'
    C_GREEN='\033[0;32m'
    C_YELLOW='\033[0;33m'
    C_BLUE='\033[0;34m'
    C_PURPLE='\033[0;35m'
    C_CYAN='\033[0;36m'
    C_WHITE='\033[0;37m'
    # Bright variants for maximum impact
    C_BRED='\033[1;31m'
    C_BGREEN='\033[1;32m'
    C_BYELLOW='\033[1;33m'
    C_BBLUE='\033[1;34m'
    C_BPURPLE='\033[1;35m'
    C_BCYAN='\033[1;36m'
    C_BWHITE='\033[1;37m'
else
    C_RESET='' C_BOLD='' C_DIM='' C_RED='' C_GREEN='' C_YELLOW=''
    C_BLUE='' C_PURPLE='' C_CYAN='' C_WHITE='' C_BRED='' C_BGREEN=''
    C_BYELLOW='' C_BBLUE='' C_BPURPLE='' C_BCYAN='' C_BWHITE=''
fi

# --- Dramatic Functions ---

print_banner() {
    if [ "$QUIET_MODE" -eq 1 ]; then return; fi
    
    echo -e "${C_BPURPLE}"
    echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
    echo "‚ïë              ${C_BYELLOW}LOG DETECTIVE 5000‚Ñ¢${C_BPURPLE}               ‚ïë"
    echo "‚ïë        ${C_WHITE}\"Elementary, my dear Watson!\"${C_BPURPLE}         ‚ïë"
    echo "‚ïë                                                    ‚ïë"
    echo "‚ïë    ${C_BGREEN}by ShadowHarvy (Chief Digital Inspector)${C_BPURPLE}    ‚ïë"
    echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
    echo -e "${C_RESET}"
}

print_usage() {
    cat <<EOF
${C_BOLD}${C_BBLUE}Log Detective 5000‚Ñ¢ - Usage Guide${C_RESET}

${C_BOLD}SYNOPSIS${C_RESET}
    ${C_GREEN}logparse${C_RESET} [${C_YELLOW}options${C_RESET}] [${C_CYAN}logfile${C_RESET}]

${C_BOLD}DESCRIPTION${C_RESET}
    Analyzes log files with the precision of Sherlock Holmes and the drama
    of a crime scene investigation. Supports multiple log formats and analysis types.

${C_BOLD}ANALYSIS MODES${C_RESET}
    ${C_GREEN}logparse${C_RESET} ${C_YELLOW}--errors${C_RESET} ${C_CYAN}app.log${C_RESET}           ${C_DIM}# Hunt for errors and warnings${C_RESET}
    ${C_GREEN}logparse${C_RESET} ${C_YELLOW}--ips${C_RESET} ${C_CYAN}access.log${C_RESET}             ${C_DIM}# Analyze IP patterns and suspicious activity${C_RESET}
    ${C_GREEN}logparse${C_RESET} ${C_YELLOW}--performance${C_RESET} ${C_CYAN}web.log${C_RESET}       ${C_DIM}# Response times and performance metrics${C_RESET}
    ${C_GREEN}logparse${C_RESET} ${C_YELLOW}--interactive${C_RESET} ${C_CYAN}server.log${C_RESET}    ${C_DIM}# Interactive exploration mode${C_RESET}

${C_BOLD}ADVANCED EXAMPLES${C_RESET}
    ${C_GREEN}logparse${C_RESET} ${C_YELLOW}--errors --top 20${C_RESET} ${C_CYAN}error.log${C_RESET}        ${C_DIM}# Top 20 most common errors${C_RESET}
    ${C_GREEN}logparse${C_RESET} ${C_YELLOW}--ips --date today${C_RESET} ${C_CYAN}access.log${C_RESET}      ${C_DIM}# Today's IP activity${C_RESET}
    ${C_GREEN}logparse${C_RESET} ${C_YELLOW}--regex "timeout|failed"${C_RESET} ${C_CYAN}app.log${C_RESET}  ${C_DIM}# Custom pattern search${C_RESET}
    ${C_GREEN}logparse${C_RESET} ${C_YELLOW}--json --errors${C_RESET} ${C_CYAN}log.txt${C_RESET} > ${C_PURPLE}report.json${C_RESET} ${C_DIM}# JSON output for scripts${C_RESET}

${C_BOLD}OPTIONS${C_RESET}
    ${C_YELLOW}-e, --errors${C_RESET}         Hunt for errors, warnings, and exceptions
    ${C_YELLOW}-i, --ips${C_RESET}           Analyze IP addresses and access patterns
    ${C_YELLOW}-p, --performance${C_RESET}   Response times and performance metrics
    ${C_YELLOW}-t, --top N${C_RESET}         Show top N results (default: 10)
    ${C_YELLOW}-f, --format TYPE${C_RESET}   Log format (apache, nginx, json, syslog, auto)
    ${C_YELLOW}-d, --date RANGE${C_RESET}    Filter by date (today, yesterday, YYYY-MM-DD)
    ${C_YELLOW}-r, --regex PATTERN${C_RESET} Custom regex pattern matching
    ${C_YELLOW}-j, --json${C_RESET}          Output results as JSON
    ${C_YELLOW}-c, --csv${C_RESET}           Output results as CSV
    ${C_YELLOW}-I, --interactive${C_RESET}   Interactive exploration mode
    ${C_YELLOW}-q, --quiet${C_RESET}         Less theatrical output
    ${C_YELLOW}-h, --help${C_RESET}          Show this help message
    ${C_YELLOW}-v, --version${C_RESET}       Display version information

${C_BOLD}SUPPORTED FORMATS${C_RESET}
    ${C_CYAN}apache${C_RESET}    Apache access/error logs
    ${C_CYAN}nginx${C_RESET}     Nginx access/error logs  
    ${C_CYAN}json${C_RESET}      JSON-structured logs
    ${C_CYAN}syslog${C_RESET}    System log format
    ${C_CYAN}auto${C_RESET}      Auto-detect format (default)

${C_BOLD}EXIT CODES${C_RESET}
    ${C_GREEN}0${C_RESET}  Analysis completed successfully
    ${C_YELLOW}1${C_RESET}  No significant findings
    ${C_RED}2${C_RESET}  Invalid arguments or file access issues
    ${C_BRED}3${C_RESET}  Parsing errors encountered

${C_DIM}Pro tip: Use interactive mode for exploring unfamiliar log formats!${C_RESET}
EOF
}

detect_log_format() {
    local file="$1"
    local sample
    
    # Get first few lines for analysis
    sample=$(head -n 10 "$file" 2>/dev/null || echo "")
    
    if [[ "$sample" =~ ^\{.*\}$ ]] || [[ "$sample" =~ \"timestamp\"|\"level\"|\"message\" ]]; then
        echo "json"
    elif [[ "$sample" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}.*\"GET|POST|PUT|DELETE ]]; then
        echo "apache"
    elif [[ "$sample" =~ ^\[[0-9]{4}/[0-9]{2}/[0-9]{2} ]]; then
        echo "nginx"  
    elif [[ "$sample" =~ ^[A-Z][a-z]{2}[[:space:]]+[0-9]{1,2}[[:space:]]+[0-9]{2}:[0-9]{2}:[0-9]{2} ]]; then
        echo "syslog"
    else
        echo "generic"
    fi
}

progress_bar() {
    if [ "$QUIET_MODE" -eq 1 ]; then return; fi
    
    local current=$1
    local total=$2
    local width=50
    local percentage=$((current * 100 / total))
    local completed=$((current * width / total))
    
    printf "\r${C_CYAN}Investigating: ["
    printf "%*s" "$completed" | tr ' ' '‚ñà'
    printf "%*s" $((width - completed)) | tr ' ' '‚ñë'
    printf "] %d%% (%d/%d lines)${C_RESET}" "$percentage" "$current" "$total"
}

analyze_errors() {
    local file="$1"
    local format="$2"
    
    echo -e "${C_BRED}üîç ERROR ANALYSIS REPORT${C_RESET}"
    echo -e "${C_DIM}Investigating suspicious activities and error patterns...${C_RESET}"
    echo ""
    
    # Common error patterns
    local error_patterns=(
        "error|ERROR"
        "warn|WARN|warning|WARNING"  
        "fail|FAIL|failed|FAILED"
        "exception|Exception|EXCEPTION"
        "fatal|FATAL|critical|CRITICAL"
        "timeout|TIMEOUT"
        "refused|denied|rejected"
        "404|500|502|503|504"
    )
    
    local total_lines
    total_lines=$(wc -l < "$file")
    
    echo -e "${C_YELLOW}üìä Error Statistics:${C_RESET}"
    
    for pattern in "${error_patterns[@]}"; do
        local count
        count=$(grep -cE "$pattern" "$file" 2>/dev/null || echo "0")
        if [[ "$count" =~ ^[0-9]+$ ]] && [ "$count" -gt 0 ]; then
            echo -e "   ${C_RED}‚Ä¢${C_RESET} $pattern: ${C_YELLOW}$count${C_RESET} occurrences"
        fi
    done
    
    echo ""
    echo -e "${C_YELLOW}üéØ Top $TOP_N Most Common Errors:${C_RESET}"
    
    # Extract and count unique error messages
    grep -hE "error|ERROR|fail|FAIL|exception|Exception" "$file" 2>/dev/null | \
    sed 's/.*\(error\|ERROR\|fail\|FAIL\|exception\|Exception\)[: ]*//' | \
    sort | uniq -c | sort -rn | head -n "$TOP_N" | \
    while read -r count message; do
        echo -e "   ${C_RED}$count${C_RESET} √ó ${C_WHITE}${message:0:80}${C_RESET}"
    done
    
    # Recent errors (last 20)
    echo ""
    echo -e "${C_YELLOW}üïê Recent Errors (Last 20):${C_RESET}"
    grep -E "error|ERROR|fail|FAIL|exception|Exception" "$file" 2>/dev/null | tail -n 20 | \
    while IFS= read -r line; do
        echo -e "   ${C_DIM}${line:0:100}${C_RESET}"
    done
}

analyze_ips() {
    local file="$1"
    local format="$2"
    
    echo -e "${C_BCYAN}üåê IP ADDRESS ANALYSIS REPORT${C_RESET}"
    echo -e "${C_DIM}Tracking digital footprints and access patterns...${C_RESET}"
    echo ""
    
    # Extract IP addresses based on format
    local ip_pattern=""
    case "$format" in
        "apache"|"nginx")
            ip_pattern='([0-9]{1,3}\.){3}[0-9]{1,3}'
            ;;
        *)
            ip_pattern='([0-9]{1,3}\.){3}[0-9]{1,3}'
            ;;
    esac
    
    # Top IP addresses
    echo -e "${C_YELLOW}üéØ Top $TOP_N Most Active IP Addresses:${C_RESET}"
    grep -oE "$ip_pattern" "$file" 2>/dev/null | \
    sort | uniq -c | sort -rn | head -n "$TOP_N" | \
    while read -r count ip; do
        # Try to identify suspicious patterns
        local status=""
        if [ "$count" -gt 1000 ]; then
            status="${C_RED}üö® SUSPICIOUS${C_RESET}"
        elif [ "$count" -gt 100 ]; then
            status="${C_YELLOW}‚ö†Ô∏è  HIGH${C_RESET}"
        else
            status="${C_GREEN}‚úÖ NORMAL${C_RESET}"
        fi
        
        echo -e "   ${C_CYAN}$ip${C_RESET} ‚Üí ${C_YELLOW}$count${C_RESET} requests $status"
    done
    
    # Unique IPs count
    local unique_ips
    unique_ips=$(grep -oE "$ip_pattern" "$file" 2>/dev/null | sort -u | wc -l)
    
    echo ""
    echo -e "${C_YELLOW}üìà Access Statistics:${C_RESET}"
    echo -e "   ${C_GREEN}‚Ä¢${C_RESET} Unique IP addresses: ${C_YELLOW}$unique_ips${C_RESET}"
    
    # Potential security concerns
    echo ""
    echo -e "${C_YELLOW}üîí Security Analysis:${C_RESET}"
    
    # Look for common attack patterns in the log
    local attack_patterns=(
        "admin|Admin|ADMIN"
        "login|Login|LOGIN" 
        "passwd|password|Password"
        "\.\./"
        "SELECT.*FROM"
        "<script"
    )
    
    for pattern in "${attack_patterns[@]}"; do
        local count
        count=$(grep -cE "$pattern" "$file" 2>/dev/null || echo "0")
        if [[ "$count" =~ ^[0-9]+$ ]] && [ "$count" -gt 0 ]; then
            echo -e "   ${C_RED}‚ö†Ô∏è${C_RESET}  Potential attack pattern '$pattern': ${C_YELLOW}$count${C_RESET} times"
        fi
    done
}

analyze_performance() {
    local file="$1" 
    local format="$2"
    
    echo -e "${C_BGREEN}‚ö° PERFORMANCE ANALYSIS REPORT${C_RESET}"
    echo -e "${C_DIM}Measuring the speed of digital lightning...${C_RESET}"
    echo ""
    
    case "$format" in
        "apache"|"nginx")
            # Extract response times from access logs (assuming they're in the log)
            echo -e "${C_YELLOW}üöÄ Response Time Analysis:${C_RESET}"
            
            # Look for response time patterns (common in Apache/Nginx logs)
            if grep -qE '[0-9]+ms|[0-9]+\.[0-9]+s' "$file"; then
                echo -e "   ${C_GREEN}‚Ä¢${C_RESET} Found response time data in logs"
                
                # Extract and analyze response times
                grep -oE '[0-9]+(\.[0-9]+)?[ms]' "$file" | \
                sort -n | \
                awk '
                {
                    times[NR] = $1;
                    sum += $1;
                    if ($1 > max) max = $1;
                    if (min == "" || $1 < min) min = $1;
                }
                END {
                    if (NR > 0) {
                        avg = sum / NR;
                        print "   Average response time: " avg "ms";
                        print "   Minimum response time: " min "ms"; 
                        print "   Maximum response time: " max "ms";
                        
                        # Calculate percentiles
                        p95_idx = int(NR * 0.95);
                        p99_idx = int(NR * 0.99);
                        print "   95th percentile: " times[p95_idx] "ms";
                        print "   99th percentile: " times[p99_idx] "ms";
                    }
                }'
            else
                echo -e "   ${C_YELLOW}‚ö†Ô∏è${C_RESET}  No explicit response time data found"
            fi
            ;;
        *)
            echo -e "${C_YELLOW}üìä Log Activity Analysis:${C_RESET}"
            
            # Analyze log entry frequency as a performance indicator
            local total_lines
            total_lines=$(wc -l < "$file")
            
            echo -e "   ${C_GREEN}‚Ä¢${C_RESET} Total log entries: ${C_YELLOW}$total_lines${C_RESET}"
            
            # Entries per hour analysis (if timestamp detectable)
            echo -e "   ${C_GREEN}‚Ä¢${C_RESET} Analyzing temporal patterns..."
            
            # Try to extract hour patterns
            if grep -qE '[0-9]{2}:[0-9]{2}:[0-9]{2}' "$file"; then
                echo -e "\n   ${C_CYAN}Activity by Hour:${C_RESET}"
                grep -oE '[0-9]{2}:[0-9]{2}:[0-9]{2}' "$file" | \
                cut -d':' -f1 | sort | uniq -c | sort -k2n | \
                while read -r count hour; do
                    echo -e "   ${hour}:xx ‚Üí ${C_YELLOW}${count}${C_RESET} entries"
                done
            fi
            ;;
    esac
}

interactive_mode() {
    local file="$1"
    
    echo -e "${C_BBLUE}üéÆ INTERACTIVE INVESTIGATION MODE${C_RESET}"
    echo -e "${C_WHITE}Welcome to the Log Detective's interactive crime lab!${C_RESET}"
    echo -e "${C_DIM}File: $file${C_RESET}"
    echo ""
    
    local format
    format=$(detect_log_format "$file")
    echo -e "${C_GREEN}üîç Detected format: ${C_YELLOW}$format${C_RESET}"
    echo ""
    
    while true; do
        echo -e "${C_CYAN}Choose your investigation:${C_RESET}"
        echo "  1) üîç Error Analysis"
        echo "  2) üåê IP Address Analysis" 
        echo "  3) ‚ö° Performance Analysis"
        echo "  4) üîé Custom Search (regex)"
        echo "  5) üìä Log Summary"
        echo "  6) üö™ Exit Investigation"
        echo ""
        
        echo -ne "${C_YELLOW}Detective's choice${C_RESET} > "
        read -r choice
        
        case "$choice" in
            1|"error"|"errors")
                echo ""
                analyze_errors "$file" "$format"
                echo ""
                ;;
            2|"ip"|"ips") 
                echo ""
                analyze_ips "$file" "$format"
                echo ""
                ;;
            3|"perf"|"performance")
                echo ""
                analyze_performance "$file" "$format"
                echo ""
                ;;
            4|"search"|"regex")
                echo -ne "${C_YELLOW}Enter regex pattern${C_RESET} > "
                read -r pattern
                if [ -n "$pattern" ]; then
                    echo ""
                    echo -e "${C_YELLOW}üîç Custom Search Results:${C_RESET}"
                    grep -nE "$pattern" "$file" | head -n 20 | \
                    while IFS=: read -r line_num content; do
                        echo -e "   ${C_DIM}$line_num:${C_RESET} $content"
                    done
                    echo ""
                fi
                ;;
            5|"summary"|"stats")
                echo ""
                show_log_summary "$file" "$format"
                echo ""
                ;;
            6|"exit"|"quit"|"q"|"")
                echo -e "${C_GREEN}üé© Investigation complete! Elementary, my dear Watson.${C_RESET}"
                break
                ;;
            *)
                echo -e "${C_RED}‚ùå Invalid choice. Try again, detective.${C_RESET}"
                ;;
        esac
    done
}

show_log_summary() {
    local file="$1"
    local format="$2"
    
    echo -e "${C_BYELLOW}üìã LOG SUMMARY REPORT${C_RESET}"
    echo -e "${C_DIM}Elementary deductions about your log file...${C_RESET}"
    echo ""
    
    local total_lines file_size
    total_lines=$(wc -l < "$file")
    file_size=$(du -h "$file" | cut -f1)
    
    echo -e "${C_YELLOW}üìÅ File Information:${C_RESET}"
    echo -e "   ${C_GREEN}‚Ä¢${C_RESET} File: ${C_CYAN}$file${C_RESET}"
    echo -e "   ${C_GREEN}‚Ä¢${C_RESET} Format: ${C_PURPLE}$format${C_RESET}"
    echo -e "   ${C_GREEN}‚Ä¢${C_RESET} Size: ${C_YELLOW}$file_size${C_RESET}"
    echo -e "   ${C_GREEN}‚Ä¢${C_RESET} Lines: ${C_YELLOW}$total_lines${C_RESET}"
    
    echo ""
    echo -e "${C_YELLOW}üîç Quick Analysis:${C_RESET}"
    
    # Error count
    local error_count
    error_count=$(grep -ciE "error|fail|exception" "$file" 2>/dev/null || echo "0")
    echo -e "   ${C_GREEN}‚Ä¢${C_RESET} Potential errors: ${C_RED}$error_count${C_RESET}"
    
    # Date range
    if grep -qE '[0-9]{4}-[0-9]{2}-[0-9]{2}|[0-9]{2}/[0-9]{2}/[0-9]{4}' "$file"; then
        echo -e "   ${C_GREEN}‚Ä¢${C_RESET} Contains timestamp data: ${C_GREEN}Yes${C_RESET}"
    else
        echo -e "   ${C_GREEN}‚Ä¢${C_RESET} Contains timestamp data: ${C_YELLOW}Uncertain${C_RESET}"
    fi
    
    # IP addresses
    local ip_count
    ip_count=$(grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}' "$file" 2>/dev/null | sort -u | wc -l || echo "0")
    if [ "$ip_count" -gt 0 ]; then
        echo -e "   ${C_GREEN}‚Ä¢${C_RESET} Unique IP addresses: ${C_CYAN}$ip_count${C_RESET}"
    fi
}

main() {
    local logfile=""
    
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -e|--errors)
                ANALYSIS_TYPE="errors"
                shift
                ;;
            -i|--ips)
                ANALYSIS_TYPE="ips"
                shift
                ;;
            -p|--performance)
                ANALYSIS_TYPE="performance"
                shift
                ;;
            -t|--top)
                TOP_N="$2"
                shift 2
                ;;
            -f|--format)
                FORMAT_TYPE="$2"
                shift 2
                ;;
            -d|--date)
                DATE_RANGE="$2"
                shift 2
                ;;
            -r|--regex)
                CUSTOM_REGEX="$2"
                ANALYSIS_TYPE="custom"
                shift 2
                ;;
            -j|--json)
                OUTPUT_FORMAT="json"
                shift
                ;;
            -c|--csv)
                OUTPUT_FORMAT="csv"
                shift
                ;;
            -I|--interactive)
                INTERACTIVE_MODE=1
                shift
                ;;
            -q|--quiet)
                QUIET_MODE=1
                shift
                ;;
            -h|--help)
                print_usage
                exit 0
                ;;
            -v|--version)
                echo "Log Detective 5000‚Ñ¢ v$SCRIPT_VERSION"
                echo "by ShadowHarvy (Chief Digital Investigator)"
                exit 0
                ;;
            -*)
                echo -e "${C_RED}‚ùå Unknown option: $1${C_RESET}" >&2
                echo -e "${C_YELLOW}üí° Try '$0 --help' for usage information${C_RESET}" >&2
                exit 2
                ;;
            *)
                logfile="$1"
                shift
                ;;
        esac
    done
    
    # Validate log file
    if [ -z "$logfile" ]; then
        echo -e "${C_RED}‚ùå No log file specified${C_RESET}" >&2
        echo -e "${C_YELLOW}üí° Usage: $0 [options] <logfile>${C_RESET}" >&2
        exit 2
    fi
    
    if [ ! -f "$logfile" ]; then
        echo -e "${C_RED}‚ùå File '$logfile' not found${C_RESET}" >&2
        exit 2
    fi
    
    if [ ! -r "$logfile" ]; then
        echo -e "${C_RED}‚ùå Cannot read file '$logfile'${C_RESET}" >&2
        exit 2
    fi
    
    # Show banner
    print_banner
    sleep 1
    
    # Auto-detect format if needed
    local detected_format
    if [ "$FORMAT_TYPE" = "auto" ]; then
        detected_format=$(detect_log_format "$logfile")
        if [ "$QUIET_MODE" -eq 0 ]; then
            echo -e "${C_GREEN}üîç Auto-detected format: ${C_YELLOW}$detected_format${C_RESET}"
            echo ""
        fi
    else
        detected_format="$FORMAT_TYPE"
    fi
    
    # Interactive mode
    if [ "$INTERACTIVE_MODE" -eq 1 ]; then
        interactive_mode "$logfile"
        exit 0
    fi
    
    # If no analysis type specified, default to summary
    if [ -z "$ANALYSIS_TYPE" ]; then
        ANALYSIS_TYPE="summary"
    fi
    
    # Perform analysis
    case "$ANALYSIS_TYPE" in
        "errors")
            analyze_errors "$logfile" "$detected_format"
            ;;
        "ips")
            analyze_ips "$logfile" "$detected_format" 
            ;;
        "performance")
            analyze_performance "$logfile" "$detected_format"
            ;;
        "custom")
            echo -e "${C_BYELLOW}üîç CUSTOM SEARCH RESULTS${C_RESET}"
            echo -e "${C_DIM}Pattern: $CUSTOM_REGEX${C_RESET}"
            echo ""
            grep -nE "$CUSTOM_REGEX" "$logfile" | head -n "$TOP_N" | \
            while IFS=: read -r line_num content; do
                echo -e "   ${C_DIM}$line_num:${C_RESET} $content"
            done
            ;;
        "summary")
            show_log_summary "$logfile" "$detected_format"
            ;;
    esac
    
    # Final flourish
    if [ "$QUIET_MODE" -eq 0 ]; then
        echo ""
        echo -e "${C_BGREEN}üéØ Investigation complete! The case has been solved.${C_RESET}"
        echo -e "${C_DIM}\"The game is afoot!\" - Log Detective 5000‚Ñ¢${C_RESET}"
    fi
}

# --- Script Entry Point ---
main "$@"