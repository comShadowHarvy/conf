#!/usr/bin/env bash
# ========================
# General Functions
# ========================

# Create a directory and navigate to it
mkcd() {
    [[ -z "$1" ]] && { echo "Usage: mkcd <directory>"; return 1; }
    mkdir -p "$1" && cd "$1" || return 1
}

# Navigate to a directory matching a pattern
cdf() {
    [[ -z "$1" ]] && { echo "Usage: cdf <pattern>"; return 1; }
    local dir
    dir=$(find . -maxdepth 1 -type d -name "*$1*" | head -n 1)
    [[ -n "$dir" ]] && cd "$dir" || { echo "No directory matching pattern '$1' found."; return 1; }
}

# Extract wisdom from YouTube transcripts (requires yt and fabric)
ytt() {
    [[ -z "$1" ]] && { echo "Usage: ytt <youtube_link>"; return 1; }
    command -v yt &>/dev/null && command -v fabric &>/dev/null || { echo "Error: Both 'yt' and 'fabric' must be installed."; return 1; }
    yt --transcript "$1" | fabric --stream --pattern extract_wisdom
}

# Extract various archive formats
extract() {
    if [[ -z "$1" || "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: extract <archive> [directory]"
        echo "Supports: tar.bz2, tar.gz, tar.xz, bz2, gz, zip, rar, 7z, etc."
        return 0
    fi

    [[ ! -f "$1" ]] && { echo "File '$1' not found."; return 1; }

    # If a destination directory is provided
    local original_dir=""
    if [[ -n "$2" ]]; then
        mkdir -p "$2"
        original_dir=$(pwd)
        cd "$2" || return 1
    fi

    case "$1" in
        *.tar.bz2|*.tbz2|*.tbz) tar xjf "$1" ;;
        *.tar.gz|*.tgz) tar xzf "$1" ;;
        *.tar.xz) tar xJf "$1" ;;
        *.tar) tar xf "$1" ;;
        *.zip) unzip "$1" ;;
        *.rar) unrar x "$1" ;;
        *.7z) 7z x "$1" ;;
        *.gz) gunzip "$1" ;;
        *.bz2) bunzip2 "$1" ;;
        *.xz|*.txz|*.lzma|*.tlz) xz -d "$1" ;;
        *) echo "Unsupported file type: $1" ;;
    esac

    # Return to original directory if needed
    [[ -n "$original_dir" ]] && cd "$original_dir" || true
}

# ========================
# Yazi File Manager
# ========================

# Main aliases
alias y='yazi'
alias ya='yazi .'
alias yh='yazi ~'
alias yd='yazi ~/Downloads'

# Function to navigate to a directory and then open yazi
cdz() { [[ -z "$1" ]] && yazi . || (cd "$1" && yazi .); }

# Function to open yazi in a directory, and cd to that directory when exiting yazi
ycd() {
    local tmp cwd
    tmp="$(mktemp -t "yazi-cwd.XXXXX")"
    yazi --cwd-file="$tmp" "$@"
    
    if cwd="$(cat -- "$tmp")" && [[ -n "$cwd" && "$cwd" != "$PWD" ]]; then
        cd -- "$cwd" || return 1
    fi
    rm -f -- "$tmp"
}

# ========================
# File Management
# ========================

# Enhanced file management aliases
alias cp="rsync -avhW --no-compress --progress"
alias mkdir='mkdir -pv'

# File listing utilities - Use eza if available
if command -v eza >/dev/null 2>&1; then
    alias ls='eza -a --icons'
    alias ll='eza -al --icons'
    alias lt='eza -a --tree --level=1 --icons'
    alias la='eza -la --icons'
    alias lm='eza -la --sort=modified --icons'
    alias lS='eza -la --sort=size --icons'
else
    # Colorized ls fallbacks
    alias ls="ls --color=auto"
    alias ll="ls -la --color=auto"
    alias l.="ls -d .* --color=auto"
    alias la="ls -la --color=auto"
    alias lm="ls -la --color=auto -t"
    alias lS="ls -la --color=auto -S"
fi

# Use fd instead of find if available
command -v fd >/dev/null 2>&1 && alias findr='fd'

# Combined search function with optimal tool selection
ftext() {
    [[ $# -eq 0 ]] && { echo "Usage: ftext <search_pattern> [path]"; return 1; }
    
    local pattern=$1
    local path=${2:-.}
    
    if command -v rg &>/dev/null; then
        rg --color=always --line-number --smart-case "$pattern" "$path"
    else
        grep -r --color=always -n "$pattern" "$path"
    fi
}

# Optimized directory finder
fdir() {
    [[ -z "$1" ]] && { echo "Usage: fdir <pattern> [max_depth]"; return 1; }
    
    local pattern=$1
    local depth=${2:-3}
    
    if command -v fd &>/dev/null; then
        fd --type d --max-depth "$depth" "$pattern"
    else
        find . -maxdepth "$depth" -type d -name "*$pattern*" | sort
    fi
}

# ========================
# System Management
# ========================

alias please="sudo !!"
alias h="history"
alias j="jobs -l"
alias reload="exec ${SHELL} -l"
alias meminfo="free -m -l -t"
alias psmem="ps auxf | sort -nr -k 4 | head -10"
alias pscpu="ps auxf | sort -nr -k 3 | head -10"
alias cpuinfo="lscpu"
alias ports="netstat -tulanp"
alias lsport="sudo lsof -i"
alias ip="dig +short myip.opendns.com @resolver1.opendns.com"
alias localip="hostname -I | awk '{print \$1}'"

# Optimized directory summary with parallel execution if available
dirsummary() {
    local dir=${1:-.}
    
    echo "📂 Directory Summary for: $(realpath "$dir")"
    echo "───────────────────────────────────────"
    
    # Run find operations in background if possible
    local total_items files dirs
    {
        total_items=$(find "$dir" -type f -o -type d | wc -l)
        files=$(find "$dir" -type f | wc -l)
        dirs=$(find "$dir" -type d | wc -l)
    } &
    
    # Get size in the meantime
    local size
    size=$(du -sh "$dir" | cut -f1)
    
    # Wait for background jobs to complete
    wait
    
    echo "📊 Stats:"
    echo "  Total items: $total_items"
    echo "  Files: $files"
    echo "  Directories: $dirs"
    echo "  Total size: $size"
    
    echo -e "\n📑 File types:"
    find "$dir" -type f | grep -v "^\." | grep -o "\.[^\.]*$" | sort | uniq -c | sort -rn | head -10
    
    echo -e "\n🕒 Recently modified files:"
    find "$dir" -type f -mtime -7 | head -5
    
    echo -e "\n📁 Largest subdirectories:"
    du -h --max-depth=1 "$dir" | sort -hr | head -5
}

# ========================
# Networking
# ========================

# Nmap presets
alias nmap_open_ports="nmap --open"
alias nmap_list_interfaces="nmap --iflist"
alias nmap_slow="sudo nmap -sS -v -T1"
alias nmap_fin="sudo nmap -sF -v"
alias nmap_fast="nmap -F -T5 --version-light --top-ports 300"
alias nmap_full="sudo nmap -sS -T4 -PE -PP -PS80,443 -PY -g 53 -A -p1-65535 -v"

# Improved file sharing function with better cleanup
share() {
    local port=${2:-8000}
    
    [[ -z "$1" ]] && { 
        echo "Usage: share <file_or_directory> [port]"
        echo "Starts a simple HTTP server to share a file or directory."
        return 1
    }
    
    [[ ! -e "$1" ]] && { echo "Error: $1 does not exist."; return 1; }
    
    local ip
    ip=$(hostname -I | awk '{print $1}')
    
    # Trap for cleanup
    local temp_dir=""
    
    # Function to handle cleanup
    cleanup() {
        [[ -n "$temp_dir" && -d "$temp_dir" ]] && rm -rf "$temp_dir"
        echo -e "\nServer stopped."
    }
    
    trap cleanup INT TERM EXIT
    
    if [[ -d "$1" ]]; then
        echo "Sharing directory at http://$ip:$port/"
        (cd "$1" && python3 -m http.server "$port")
    else
        temp_dir=$(mktemp -d)
        local filename=$(basename "$1")
        cp "$1" "$temp_dir"
        
        echo "Sharing $filename at http://$ip:$port/$filename"
        (cd "$temp_dir" && python3 -m http.server "$port")
    fi
}

# ========================
# Media & Downloads
# ========================

alias ytmp3="youtube-dl --extract-audio --audio-format mp3"
alias ytmp4="youtube-dl -f 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/mp4'"
alias wget='wget --no-hsts -c'
alias get='wget -m -np -c -R "index.html*"'
alias playmp3='for i in *.mp3; do mplayer "$i"; done'
alias music="mplayer --shuffle *"

# ========================
# Navigation
# ========================

alias ..="cd .."
alias ...="cd ../.."
alias ....="cd ../../.."
alias .....="cd ../../../.."
alias ~="cd ~"
alias dl="cd ~/Downloads"
alias dt="cd ~/Desktop"
alias p="cd ~/projects"
alias doc="cd ~/Documents"

# ========================
# Git and Development
# ========================

# App launchers
command -v flatpak >/dev/null 2>&1 && alias code="flatpak run com.visualstudio.code"
command -v flatpak >/dev/null 2>&1 && alias studio="flatpak run com.visualstudio.code"

# Git utilities
alias gitstatus="git status -s"
alias gita="git add -A"
alias gitcm="git commit -m"
alias gitp="git push"
alias gitpl="git pull"
alias gitf="git fetch"
alias gits="git stash"
alias gitsp="git stash pop"
alias gitb="git branch"
alias gitco="git checkout"
alias gitcb="git checkout -b"
alias gri="git rebase -i"
alias glog="git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit"
alias gitclean="git clean -fd"
alias gc="git clone"

# Git clone and cd into the cloned directory
gcc() {
    [[ -z "$1" ]] && { echo "Usage: gcc <repository_url> [directory]"; return 1; }
    
    local repo_url="$1"
    local dir_name
    
    # If second argument is provided, use it as the directory name
    if [[ -n "$2" ]]; then
        dir_name="$2"
        git clone "$repo_url" "$dir_name" && cd "$dir_name" || return 1
    else
        # Extract directory name from repo URL (remove .git extension if present)
        dir_name=$(basename "$repo_url" .git)
        git clone "$repo_url" && cd "$dir_name" || return 1
    fi
}

# Improved quickgit with better error handling
quickgit() {
    [[ -z "$1" ]] && { 
        echo "Usage: quickgit <commit message>"
        echo "Stages all changes, commits with the provided message, and pushes to the remote repository."
        return 1
    }
    
    # Check if in a git repository
    git rev-parse --is-inside-work-tree &>/dev/null || { 
        echo "Error: Not in a git repository."
        return 1
    }
    
    # Show what's being staged
    git status -s
    echo "Staging all changes..."
    git add . || { echo "Error staging changes."; return 1; }
    
    # Commit with the provided message
    echo "Committing with message: $*"
    git commit -m "$*" || { echo "Error committing changes."; return 1; }
    
    # Check if there's a remote repository and push
    if git remote | grep -q .; then
        echo "Pushing to remote..."
        git push || echo "Warning: Push failed, but commit was successful."
    else
        echo "No remote repository configured. Skipping push."
    fi
}

# Optimized git update function
gitupdate() {
    # Check if in a git repository
    git rev-parse --is-inside-work-tree &>/dev/null || { 
        echo "Error: Not in a git repository."
        return 1
    }
    
    local current_branch
    current_branch=$(git rev-parse --abbrev-ref HEAD)
    
    echo "Updating branch: $current_branch"
    
    # Stash any changes if needed
    local stashed=false
    if ! git diff --quiet; then
        echo "Stashing local changes..."
        git stash && stashed=true || {
            echo "Error: Failed to stash changes."
            return 1
        }
    fi
    
    # Define cleanup function to ensure stash is applied on exit
    cleanup() {
        if [[ "$stashed" == true ]]; then
            echo "Applying stashed changes..."
            git stash pop || echo "Warning: Failed to apply stashed changes."
        fi
    }
    
    # Set up trap to ensure cleanup runs on error or exit
    trap cleanup ERR EXIT
    
    # Fetch updates
    echo "Fetching latest changes..."
    git fetch || {
        echo "Error: Failed to fetch changes."
        return 1
    }
    
    # Check if there are upstream changes for the current branch
    if git rev-parse --verify origin/$current_branch >/dev/null 2>&1; then
        # Rebase on top of upstream changes
        echo "Rebasing on origin/$current_branch..."
        git rebase origin/$current_branch || {
            echo "Error: Rebase failed. Resolving conflicts may be required."
            return 1
        }
    else
        echo "No upstream branch found for $current_branch"
    fi
    
    echo "Update complete!"
    # Trap will handle applying stashed changes
}

# Improved script generator with template selection
mkscript() {
    [[ -z "$1" ]] && { echo "Usage: mkscript <script_name> [template]"; return 1; }
    
    # Add .sh extension if not provided
    local FILE
    [[ "$1" != *.* ]] && FILE="$1.sh" || FILE="$1"
    local TEMPLATE=${2:-basic}
    
    # Check if file already exists
    [[ -f "$FILE" ]] && { echo "Error: $FILE already exists."; return 1; }
    
    case "$TEMPLATE" in
        basic)
            cat > "$FILE" << 'EOF'
#!/usr/bin/env bash

# Created on: $(date)
# Description: 

set -euo pipefail  # Exit on error, undefined vars, and pipe failures

# Main script body
main() {
    echo "Hello, World!"
}

main "$@"
EOF
            ;;
        advanced)
            cat > "$FILE" << 'EOF'
#!/usr/bin/env bash

# Created on: $(date)
# Description: 

set -euo pipefail  # Exit on error, undefined vars, and pipe failures

# Script variables
readonly SCRIPT_NAME=$(basename "$0")
readonly SCRIPT_DIR=$(dirname "$(readlink -f "$0")")

# Print usage information
usage() {
    cat << EOF
Usage: $SCRIPT_NAME [options] <arguments>

Options:
  -h, --help      Show this help message and exit
  -v, --verbose   Enable verbose output

Arguments:
  arg1            Description of arg1

Example:
  $SCRIPT_NAME arg1
EOF
}

# Parse command line arguments
parse_args() {
    VERBOSE=false
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                usage
                exit 0
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            *)
                ARG1="$1"
                shift
                ;;
        esac
    done
    
    # Validate arguments
    if [[ -z "${ARG1:-}" ]]; then
        echo "Error: Missing required argument"
        usage
        exit 1
    fi
}

# Log message with timestamp
log() {
    local level="$1"
    shift
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [$level] $*"
}

# Print debug messages if verbose mode is enabled
debug() {
    $VERBOSE && log "DEBUG" "$@" || true
}

# Print info messages
info() {
    log "INFO" "$@"
}

# Print error messages
error() {
    log "ERROR" "$@" >&2
}

# Cleanup function called on exit
cleanup() {
    # Add cleanup code here
    debug "Cleaning up..."
}

# Main script execution
main() {
    # Register cleanup function
    trap cleanup EXIT
    
    # Parse command line arguments
    parse_args "$@"
    
    # Script logic
    info "Starting script execution"
    debug "Argument: $ARG1"
    
    # Your code here
    
    info "Script execution completed"
}

# Call main function
main "$@"
EOF
            ;;
        *)
            echo "Error: Unknown template '$TEMPLATE'"
            echo "Available templates: basic, advanced"
            return 1
            ;;
    esac
    
    # Make it executable
    chmod +x "$FILE"
    
    # Open in preferred editor
    if command -v nvim &>/dev/null; then
        nvim "$FILE"
    elif command -v code &>/dev/null; then
        code "$FILE"
    elif [[ -n "$EDITOR" ]]; then
        $EDITOR "$FILE"
    else
        echo "Created $FILE. No editor found to open it."
    fi
}

# ========================
# Fun and Miscellaneous
# ========================

command -v lolcat >/dev/null 2>&1 && alias neofetch="neofetch | lolcat"
alias lweather="ansiweather -l minto ontario"
alias now="date +%T"
alias week="date +%V"
alias chx="chmod +x"
alias :q="exit"
alias today='date "+%Y-%m-%d"'

# ========================
# Tmux Shortcuts
# ========================

alias ta="tmux attach -t"
alias ts="tmux new-session -s"
alias tl="tmux list-sessions"
alias tk="tmux kill-session -t"
alias tn="tmux new -s"
alias tsw="tmux switch-client -t"

# ========================
# Miscellaneous Tools
# ========================

alias bc="bc -l"
alias sha1="openssl sha1"
alias sha256="openssl sha256"
alias md5="openssl md5"
alias flushmcd='echo "flush_all" | nc 10.10.27.11 11211'
alias vnstat="vnstat -i eth1"
alias df="df -h"
alias du="du -h"

# ========================
# Default Applications
# ========================

alias browser="google-chrome-stable"
command -v flatpak >/dev/null 2>&1 && {
    alias vlc="flatpak run org.videolan.VLC"
    alias spotify="flatpak run com.spotify.Client"
    alias discord="flatpak run com.discordapp.Discord"
    alias teams="flatpak run com.microsoft.Teams"
}

# ========================
# Custom Commands
# ========================

command -v lolcat >/dev/null 2>&1 && alias loo="| lolcat"
alias grep="grep --color=auto"
command -v fd >/dev/null 2>&1 && alias fd="fd --color=auto"
alias diff="diff --color=auto"

# Highly optimized updateall function
updateall() {
    echo "🚀 Starting comprehensive system update..."
    
    # Track overall success
    local success=true
    local failed_managers=()
    
    # Function to handle updating with proper error handling
    update_with() {
        local manager=$1
        local cmd=$2
        local description=$3
        
        echo -e "\n📦 Updating $description..."
        echo "Running: $cmd"
        
        # Execute in a subshell to avoid script termination on error
        if (eval "$cmd"); then
            echo "✅ Successfully updated $description"
            return 0
        else
            echo "❌ Failed to update $description"
            success=false
            failed_managers+=("$description")
            return 1
        fi
    }
    
    # Detect distribution more efficiently
    local distro=""
    if [[ -f /etc/os-release ]]; then
        distro=$(source /etc/os-release && echo "$ID")
    fi
    
    echo "🖥️ Detected distribution: $distro"
    
    # System package manager updates
    case "$distro" in
        alpine)
            update_with "apk" "sudo apk update && sudo apk upgrade" "Alpine packages"
            ;;
        debian|ubuntu|pop|mint|kali|elementary|zorin)
            # Run all apt commands in one update_with to minimize sudo prompts
            update_with "apt" "sudo apt update && sudo apt upgrade -y && sudo apt dist-upgrade -y && sudo apt autoremove -y && sudo apt autoclean" "Debian/Ubuntu packages"
            ;;
        fedora|rhel|centos|rocky|alma)
            if command -v dnf >/dev/null 2>&1; then
                update_with "dnf" "sudo dnf upgrade --refresh -y && sudo dnf autoremove -y" "DNF packages"
            else
                update_with "yum" "sudo yum update -y && sudo yum autoremove -y" "YUM packages"
            fi
            ;;
        arch|manjaro|endeavouros|garuda)
            update_with "pacman" "sudo pacman -Syu --noconfirm && sudo paccache -rk1" "Arch packages"
            ;;
        opensuse*|suse*)
            update_with "zypper" "sudo zypper refresh && sudo zypper update -y" "openSUSE packages"
            ;;
        *)
            # Try to detect package manager if distribution couldn't be identified
            if command -v pacman >/dev/null 2>&1; then
                update_with "pacman" "sudo pacman -Syu --noconfirm" "Arch packages"
            elif command -v apt >/dev/null 2>&1; then
                update_with "apt" "sudo apt update && sudo apt upgrade -y" "Debian/Ubuntu packages"
            elif command -v dnf >/dev/null 2>&1; then
                update_with "dnf" "sudo dnf upgrade --refresh -y" "DNF packages"
            elif command -v zypper >/dev/null 2>&1; then
                update_with "zypper" "sudo zypper refresh && sudo zypper update -y" "openSUSE packages"
            elif command -v apk >/dev/null 2>&1; then
                update_with "apk" "sudo apk update && sudo apk upgrade" "Alpine packages"
            else
                echo "⚠️ Unknown distribution and no recognized package manager found."
            fi
            ;;
    esac
    
    # Update alternative package managers only if they exist
    command -v yay >/dev/null 2>&1 && update_with "yay" "yay -Syu --noconfirm" "AUR packages"
    command -v flatpak >/dev/null 2>&1 && update_with "flatpak" "flatpak update -y" "Flatpak packages"
    command -v snap >/dev/null 2>&1 && update_with "snap" "sudo snap refresh" "Snap packages"
    command -v brew >/dev/null 2>&1 && update_with "brew" "brew update && brew upgrade && brew cleanup" "Homebrew packages"
    command -v zimfw >/dev/null 2>&1 && update_with "zimfw" "zimfw update" "ZimFW"
    command -v oh-my-posh >/dev/null 2>&1 && update_with "oh-my-posh" "sudo oh-my-posh update" "Oh My Posh"
    command -v rustup >/dev/null 2>&1 && update_with "rustup" "rustup update" "Rust"
    command -v npm >/dev/null 2>&1 && update_with "npm" "npm update -g" "npm global packages"
    
    # Update pip packages if available (more efficient)
    if command -v pip >/dev/null 2>&1; then
        update_with "pip" "pip list --outdated --format=json | python3 -c \"import json, sys; print(' '.join([x['name'] for x in json.load(sys.stdin)]))\" | xargs -r pip install -U --user" "pip user packages"
    fi
    
    # Final report
    echo ""
    if [[ "$success" = true ]]; then
        echo "🎉 All updates completed successfully!"
    else
        echo "⚠️ Some updates failed. The following managers had issues:"
        for manager in "${failed_managers[@]}"; do
            echo "  - $manager"
        done
        echo "You may want to run those updates manually."
    fi
    
    # Show system information more efficiently
    echo ""
    echo "📊 System Information:"
    echo "  - Kernel: $(uname -r)"
    echo "  - Uptime: $(uptime -p)"
    command -v free >/dev/null 2>&1 && echo "  - Memory: $(free -h | awk '/^Mem:/ {print $3 " used of " $2 " total"}')"
    command -v df >/dev/null 2>&1 && echo "  - Disk: $(df -h / | awk 'NR==2 {print $3 " used of " $2 " total (" $5 " used)"}')"
}
}

# Installer shortcuts
alias christitus='curl -fsSL christitus.com/linux | sh'
alias christitusdev='curl -fsSL https://christitus.com/linuxdev | sh'

# Shell management
alias zimupdate="zimfw update"
alias reload-zsh="source ~/.zshrc"
alias edit-zsh="nvim ~/.zshrc"
alias edit-aliases="nvim ~/.aliases"

# Package installer helper
pkg-install() {
    [[ -z "$1" ]] && { echo "Usage: pkg-install <package> [--verbose]"; return 1; }
    [[ -f ~/install.sh ]] && ~/install.sh "$@" || { echo "Error: install.sh script not found in home directory."; return 1; }
}

# Quick temperature check
tempcheck() {
    if command -v sensors >/dev/null 2>&1; then
        sensors | grep -E 'Core|CPU'
    else
        echo "The 'sensors' command is not available. Try installing lm-sensors package."
    fi
}

# Improved password generator
genpass() {
    local length=${1:-16}
    if [[ ! "$length" =~ ^[0-9]+$ ]] || [[ "$length" -lt 8 ]]; then
        echo "Please specify a valid password length (minimum 8)"
        return 1
    fi
    
    if command -v openssl >/dev/null 2>&1; then
        openssl rand -base64 48 | tr -dc 'A-Za-z0-9!@#$%^&*()-_=+' | head -c "$length"; echo
    else
        tr -dc 'A-Za-z0-9!@#$%^&*()-_=+' < /dev/urandom | head -c "$length"; echo
    fi
}

# System monitoring alias
alias syswatch='watch -n2 "free -h; echo; df -h -T /"'

# Enhanced man pages with colors
if command -v batcat >/dev/null 2>&1; then
    export MANPAGER="sh -c 'col -bx | batcat -l man -p'"
    alias man='MANPAGER="sh -c \"col -bx | batcat -l man -p\"" man'
elif command -v bat >/dev/null 2>&1; then
    export MANPAGER="sh -c 'col -bx | bat -l man -p'"
    alias man='MANPAGER="sh -c \"col -bx | bat -l man -p\"" man'
fi