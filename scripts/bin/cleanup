#!/usr/bin/env bash
# ===----------------------------------------===
#          Disk Space Detective 2000™
# ===----------------------------------------===
# Author: ShadowHarvy (Chief Digital Forensics Expert)
# Version: 1.0 (Investigating digital crime scenes!)
#
# Purpose: Investigates disk space usage with the precision of CSI
#          and cleans up digital debris with forensic thoroughness.
#          Because manual disk cleanup is for digital amateurs.
#
# Usage:
#   cleanup                          # Interactive investigation
#   cleanup --analyze /home          # Analyze specific directory
#   cleanup --large 100M             # Find files larger than 100MB
#   cleanup --cache                  # Clean package caches
#   cleanup --logs                   # Clean old log files
#   cleanup --docker                 # Clean Docker artifacts
#   cleanup --safe                   # Safe cleanup (no confirmations)
#
# Options:
#   -a, --analyze DIR       Analyze disk usage in directory
#   -l, --large SIZE        Find large files (e.g., 100M, 1G)
#   -c, --cache             Clean package manager caches
#   -L, --logs              Clean old log files
#   -d, --docker            Clean Docker containers/images
#   -t, --temp              Clean temporary files
#   -s, --safe              Safe mode (conservative cleanup)
#   -f, --force             Force mode (aggressive cleanup)
#   -n, --dry-run           Show what would be cleaned (no action)
#   -q, --quiet             Less theatrical output
#   -h, --help              Show this help and exit
#   -v, --version           Show version information
#
# Investigation Areas:
#   - Package manager caches (pacman, npm, cargo, pip)
#   - Temporary files and directories
#   - Log files and journal data
#   - Docker artifacts and build cache
#   - Large files and directory analysis
#   - Duplicate file detection
#
# Exit Codes:
#   0 - Investigation completed successfully
#   1 - No significant findings or cleanup needed
#   2 - Invalid arguments or permission issues
#   3 - Critical system files at risk (safety abort)

# --- Strict Mode & Safety First ---
set -euo pipefail

# --- Script Configuration ---
SCRIPT_VERSION="1.0"
OPERATION=""
TARGET_DIR=""
LARGE_FILE_SIZE=""
SAFE_MODE=0
FORCE_MODE=0
DRY_RUN=0
QUIET_MODE=0

# Cleanup thresholds (in MB)
LOG_AGE_DAYS=30
CACHE_SIZE_THRESHOLD=100
TEMP_AGE_DAYS=7

# Temporary files for analysis
TMP_DIR="/tmp/cleanup_$$"
mkdir -p "$TMP_DIR"
trap 'rm -rf "$TMP_DIR"' EXIT

# --- Colors & Visual Flair ---
if [ -t 1 ]; then
    C_RESET='\033[0m'
    C_BOLD='\033[1m'
    C_DIM='\033[2m'
    C_RED='\033[0;31m'
    C_GREEN='\033[0;32m'
    C_YELLOW='\033[0;33m'
    C_BLUE='\033[0;34m'
    C_PURPLE='\033[0;35m'
    C_CYAN='\033[0;36m'
    C_WHITE='\033[0;37m'
    # Bright variants for evidence highlights
    C_BRED='\033[1;31m'
    C_BGREEN='\033[1;32m'
    C_BYELLOW='\033[1;33m'
    C_BBLUE='\033[1;34m'
    C_BPURPLE='\033[1;35m'
    C_BCYAN='\033[1;36m'
    C_BWHITE='\033[1;37m'
else
    C_RESET='' C_BOLD='' C_DIM='' C_RED='' C_GREEN='' C_YELLOW=''
    C_BLUE='' C_PURPLE='' C_CYAN='' C_WHITE='' C_BRED='' C_BGREEN=''
    C_BYELLOW='' C_BBLUE='' C_BPURPLE='' C_BCYAN='' C_BWHITE=''
fi

# --- Detective Functions ---

print_banner() {
    if [ "$QUIET_MODE" -eq 1 ]; then return; fi
    
    echo -e "${C_BYELLOW}"
    echo "╔════════════════════════════════════════════════════╗"
    echo "║           ${C_BWHITE}DISK SPACE DETECTIVE 2000™${C_BYELLOW}           ║"
    echo "║      ${C_CYAN}\"The truth is out there... in your disk!\"${C_BYELLOW}     ║"
    echo "║                                                    ║"
    echo "║ ${C_BGREEN}by ShadowHarvy (Chief Digital Forensics Expert)${C_BYELLOW} ║"
    echo "╚════════════════════════════════════════════════════╝"
    echo -e "${C_RESET}"
}

print_usage() {
    cat <<EOF
${C_BOLD}${C_BBLUE}Disk Space Detective 2000™ - Usage Guide${C_RESET}

${C_BOLD}SYNOPSIS${C_RESET}
    ${C_GREEN}cleanup${C_RESET} [${C_YELLOW}options${C_RESET}] [${C_CYAN}target${C_RESET}]

${C_BOLD}DESCRIPTION${C_RESET}
    Investigates disk space usage with the precision of CSI and cleans up
    digital debris with forensic thoroughness. Supports multiple cleanup strategies.

${C_BOLD}INVESTIGATION MODES${C_RESET}
    ${C_GREEN}cleanup${C_RESET}                          ${C_DIM}# Interactive forensic investigation${C_RESET}
    ${C_GREEN}cleanup${C_RESET} ${C_YELLOW}--analyze /home${C_RESET}        ${C_DIM}# Analyze specific directory${C_RESET}
    ${C_GREEN}cleanup${C_RESET} ${C_YELLOW}--large 100M${C_RESET}           ${C_DIM}# Find files larger than 100MB${C_RESET}
    ${C_GREEN}cleanup${C_RESET} ${C_YELLOW}--cache${C_RESET}                ${C_DIM}# Clean package manager caches${C_RESET}

${C_BOLD}CLEANUP OPERATIONS${C_RESET}
    ${C_GREEN}cleanup${C_RESET} ${C_YELLOW}--logs${C_RESET}                 ${C_DIM}# Clean old log files${C_RESET}
    ${C_GREEN}cleanup${C_RESET} ${C_YELLOW}--docker${C_RESET}               ${C_DIM}# Clean Docker artifacts${C_RESET}
    ${C_GREEN}cleanup${C_RESET} ${C_YELLOW}--temp${C_RESET}                 ${C_DIM}# Clean temporary files${C_RESET}
    ${C_GREEN}cleanup${C_RESET} ${C_YELLOW}--safe${C_RESET}                 ${C_DIM}# Conservative cleanup mode${C_RESET}

${C_BOLD}OPTIONS${C_RESET}
    ${C_YELLOW}-a, --analyze DIR${C_RESET}       Analyze disk usage in specific directory
    ${C_YELLOW}-l, --large SIZE${C_RESET}        Find large files (e.g., 100M, 1G, 500K)
    ${C_YELLOW}-c, --cache${C_RESET}             Clean package manager caches (pacman, npm, etc.)
    ${C_YELLOW}-L, --logs${C_RESET}              Clean old log files and journal data
    ${C_YELLOW}-d, --docker${C_RESET}            Clean Docker containers, images, and cache
    ${C_YELLOW}-t, --temp${C_RESET}              Clean temporary files and directories
    ${C_YELLOW}-s, --safe${C_RESET}              Safe mode (conservative cleanup, more prompts)
    ${C_YELLOW}-f, --force${C_RESET}             Force mode (aggressive cleanup, fewer prompts)
    ${C_YELLOW}-n, --dry-run${C_RESET}           Show what would be cleaned without doing it
    ${C_YELLOW}-q, --quiet${C_RESET}             Less theatrical output for scripts
    ${C_YELLOW}-h, --help${C_RESET}              Show this help message and exit
    ${C_YELLOW}-v, --version${C_RESET}           Display version and credentials

${C_BOLD}SIZE FORMATS${C_RESET}
    ${C_CYAN}K${C_RESET} or ${C_CYAN}KB${C_RESET} - Kilobytes    ${C_CYAN}M${C_RESET} or ${C_CYAN}MB${C_RESET} - Megabytes
    ${C_CYAN}G${C_RESET} or ${C_CYAN}GB${C_RESET} - Gigabytes    ${C_CYAN}T${C_RESET} or ${C_CYAN}TB${C_RESET} - Terabytes

${C_BOLD}INVESTIGATION AREAS${C_RESET}
    • Package manager caches (pacman, npm, cargo, pip)
    • System logs and journal data
    • Docker containers, images, and build cache
    • Temporary files and crash dumps
    • Large file analysis and recommendations

${C_DIM}Remember: The truth about your disk space is out there!${C_RESET}
EOF
}

human_size() {
    local bytes="$1"
    local units=("B" "K" "M" "G" "T")
    local unit=0
    local size=$bytes
    
    while [ "$size" -gt 1024 ] && [ "$unit" -lt 4 ]; do
        size=$((size / 1024))
        unit=$((unit + 1))
    done
    
    echo "${size}${units[$unit]}"
}

parse_size() {
    local size_str="$1"
    local number size_bytes
    
    # Extract number and unit
    if [[ "$size_str" =~ ^([0-9]+)([KMGT]?B?)$ ]]; then
        number="${BASH_REMATCH[1]}"
        local unit="${BASH_REMATCH[2]}"
        
        case "${unit^^}" in
            ""|"B") size_bytes=$number ;;
            "K"|"KB") size_bytes=$((number * 1024)) ;;
            "M"|"MB") size_bytes=$((number * 1024 * 1024)) ;;
            "G"|"GB") size_bytes=$((number * 1024 * 1024 * 1024)) ;;
            "T"|"TB") size_bytes=$((number * 1024 * 1024 * 1024 * 1024)) ;;
            *) echo "Invalid size format: $size_str" >&2; return 1 ;;
        esac
        echo "$size_bytes"
    else
        echo "Invalid size format: $size_str" >&2
        return 1
    fi
}

analyze_directory() {
    local target_dir="$1"
    
    if [ ! -d "$target_dir" ]; then
        echo -e "${C_RED}❌ Directory not found: $target_dir${C_RESET}" >&2
        return 1
    fi
    
    echo -e "${C_BCYAN}🔍 DIRECTORY FORENSIC ANALYSIS${C_RESET}"
    echo -e "${C_DIM}Examining the digital crime scene: $target_dir${C_RESET}"
    echo ""
    
    # Get directory size
    local total_size
    total_size=$(du -sb "$target_dir" 2>/dev/null | cut -f1 || echo "0")
    
    echo -e "${C_YELLOW}📊 Investigation Summary:${C_RESET}"
    echo -e "   ${C_WHITE}Directory: ${C_CYAN}$target_dir${C_RESET}"
    echo -e "   ${C_WHITE}Total Size: ${C_BGREEN}$(human_size "$total_size")${C_RESET}"
    echo ""
    
    # Top 10 largest subdirectories
    echo -e "${C_YELLOW}🎯 Top 10 Suspects (Largest Subdirectories):${C_RESET}"
    du -h "$target_dir"/* 2>/dev/null | sort -hr | head -10 | while IFS=$'\t' read -r size path; do
        echo -e "   ${C_PURPLE}$size${C_RESET} → ${C_WHITE}${path}${C_RESET}"
    done
    
    echo ""
    
    # File type analysis
    echo -e "${C_YELLOW}🔎 File Type Evidence:${C_RESET}"
    find "$target_dir" -type f -printf '%s %f\n' 2>/dev/null | \
    awk '{
        size=$1; 
        name=$2;
        if(match(name, /\.[^.]+$/)) {
            ext=substr(name, RSTART+1);
        } else {
            ext="no_extension";
        }
        total[ext] += size;
        count[ext]++;
    } 
    END {
        for(ext in total) {
            if(total[ext] > 1048576) { # Only show > 1MB
                printf "   %s: %d files, %.1fM\n", ext, count[ext], total[ext]/1048576;
            }
        }
    }' | sort -k3 -nr | head -10
}

find_large_files() {
    local size_threshold="$1"
    local search_dirs=("$HOME" "/var" "/opt" "/usr")
    
    local size_bytes
    size_bytes=$(parse_size "$size_threshold")
    
    echo -e "${C_BRED}🔍 LARGE FILE INVESTIGATION${C_RESET}"
    echo -e "${C_DIM}Hunting for files larger than $size_threshold...${C_RESET}"
    echo ""
    
    local found=0
    for search_dir in "${search_dirs[@]}"; do
        if [ -d "$search_dir" ] && [ -r "$search_dir" ]; then
            echo -e "${C_YELLOW}🎯 Investigating: $search_dir${C_RESET}"
            
            find "$search_dir" -type f -size +"$size_threshold" -exec ls -lh {} \; 2>/dev/null | \
            head -20 | while read -r perms links owner group size month day time_year path; do
                echo -e "   ${C_RED}$size${C_RESET} → ${C_WHITE}$path${C_RESET} ${C_DIM}($owner:$group)${C_RESET}"
                found=1
            done
        fi
    done
    
    if [ "$found" -eq 0 ]; then
        echo -e "${C_GREEN}✅ No suspicious large files found. Your disk is clean!${C_RESET}"
    fi
}

clean_package_caches() {
    echo -e "${C_BPURPLE}🗑️  PACKAGE CACHE CLEANUP${C_RESET}"
    echo -e "${C_DIM}Clearing out digital evidence from package managers...${C_RESET}"
    echo ""
    
    local total_freed=0
    
    # Pacman cache (Arch Linux)
    if command -v pacman >/dev/null 2>&1; then
        echo -e "${C_YELLOW}📦 Pacman Cache Cleanup:${C_RESET}"
        local pacman_cache_size
        pacman_cache_size=$(du -sb /var/cache/pacman/pkg/ 2>/dev/null | cut -f1 || echo "0")
        
        if [ "$pacman_cache_size" -gt 0 ]; then
            echo -e "   ${C_WHITE}Cache size: ${C_YELLOW}$(human_size "$pacman_cache_size")${C_RESET}"
            
            if [ "$DRY_RUN" -eq 1 ]; then
                echo -e "   ${C_DIM}[DRY RUN] Would clean pacman cache${C_RESET}"
            else
                if [ "$FORCE_MODE" -eq 1 ] || confirm_action "Clean pacman cache?"; then
                    sudo pacman -Sc --noconfirm >/dev/null 2>&1
                    echo -e "   ${C_GREEN}✅ Pacman cache cleared${C_RESET}"
                    total_freed=$((total_freed + pacman_cache_size))
                fi
            fi
        else
            echo -e "   ${C_GREEN}✅ Pacman cache already clean${C_RESET}"
        fi
    fi
    
    # NPM cache
    if command -v npm >/dev/null 2>&1; then
        echo -e "${C_YELLOW}📦 NPM Cache Cleanup:${C_RESET}"
        local npm_cache_dir
        npm_cache_dir=$(npm config get cache 2>/dev/null || echo "$HOME/.npm")
        
        if [ -d "$npm_cache_dir" ]; then
            local npm_cache_size
            npm_cache_size=$(du -sb "$npm_cache_dir" 2>/dev/null | cut -f1 || echo "0")
            
            if [ "$npm_cache_size" -gt $((CACHE_SIZE_THRESHOLD * 1048576)) ]; then
                echo -e "   ${C_WHITE}Cache size: ${C_YELLOW}$(human_size "$npm_cache_size")${C_RESET}"
                
                if [ "$DRY_RUN" -eq 1 ]; then
                    echo -e "   ${C_DIM}[DRY RUN] Would clean npm cache${C_RESET}"
                else
                    if [ "$FORCE_MODE" -eq 1 ] || confirm_action "Clean npm cache?"; then
                        npm cache clean --force >/dev/null 2>&1
                        echo -e "   ${C_GREEN}✅ NPM cache cleared${C_RESET}"
                        total_freed=$((total_freed + npm_cache_size))
                    fi
                fi
            else
                echo -e "   ${C_GREEN}✅ NPM cache is reasonably sized${C_RESET}"
            fi
        fi
    fi
    
    # Cargo cache
    if command -v cargo >/dev/null 2>&1 && [ -d "$HOME/.cargo" ]; then
        echo -e "${C_YELLOW}📦 Cargo Cache Cleanup:${C_RESET}"
        local cargo_cache_size
        cargo_cache_size=$(du -sb "$HOME/.cargo" 2>/dev/null | cut -f1 || echo "0")
        
        if [ "$cargo_cache_size" -gt $((CACHE_SIZE_THRESHOLD * 1048576)) ]; then
            echo -e "   ${C_WHITE}Cache size: ${C_YELLOW}$(human_size "$cargo_cache_size")${C_RESET}"
            
            if [ "$DRY_RUN" -eq 1 ]; then
                echo -e "   ${C_DIM}[DRY RUN] Would clean cargo cache${C_RESET}"
            else
                if [ "$FORCE_MODE" -eq 1 ] || confirm_action "Clean cargo cache?"; then
                    cargo clean >/dev/null 2>&1 || true
                    echo -e "   ${C_GREEN}✅ Cargo cache cleared${C_RESET}"
                fi
            fi
        else
            echo -e "   ${C_GREEN}✅ Cargo cache is reasonably sized${C_RESET}"
        fi
    fi
    
    # Pip cache
    if command -v pip >/dev/null 2>&1; then
        echo -e "${C_YELLOW}📦 Pip Cache Cleanup:${C_RESET}"
        local pip_cache_dir
        pip_cache_dir=$(pip cache dir 2>/dev/null || echo "$HOME/.cache/pip")
        
        if [ -d "$pip_cache_dir" ]; then
            local pip_cache_size
            pip_cache_size=$(du -sb "$pip_cache_dir" 2>/dev/null | cut -f1 || echo "0")
            
            if [ "$pip_cache_size" -gt $((CACHE_SIZE_THRESHOLD * 1048576)) ]; then
                echo -e "   ${C_WHITE}Cache size: ${C_YELLOW}$(human_size "$pip_cache_size")${C_RESET}"
                
                if [ "$DRY_RUN" -eq 1 ]; then
                    echo -e "   ${C_DIM}[DRY RUN] Would clean pip cache${C_RESET}"
                else
                    if [ "$FORCE_MODE" -eq 1 ] || confirm_action "Clean pip cache?"; then
                        pip cache purge >/dev/null 2>&1 || true
                        echo -e "   ${C_GREEN}✅ Pip cache cleared${C_RESET}"
                    fi
                fi
            else
                echo -e "   ${C_GREEN}✅ Pip cache is reasonably sized${C_RESET}"
            fi
        fi
    fi
    
    if [ "$total_freed" -gt 0 ]; then
        echo ""
        echo -e "${C_BGREEN}💰 Total space freed: $(human_size "$total_freed")${C_RESET}"
    fi
}

clean_logs() {
    echo -e "${C_BBLUE}📋 LOG FILE CLEANUP${C_RESET}"
    echo -e "${C_DIM}Clearing old evidence from the digital archives...${C_RESET}"
    echo ""
    
    # System journal cleanup
    if command -v journalctl >/dev/null 2>&1; then
        echo -e "${C_YELLOW}📝 System Journal Cleanup:${C_RESET}"
        local journal_size
        journal_size=$(journalctl --disk-usage 2>/dev/null | grep -o '[0-9.]*[KMGT]*B' || echo "0B")
        
        echo -e "   ${C_WHITE}Current size: ${C_YELLOW}$journal_size${C_RESET}"
        
        if [ "$DRY_RUN" -eq 1 ]; then
            echo -e "   ${C_DIM}[DRY RUN] Would clean journal older than ${LOG_AGE_DAYS} days${C_RESET}"
        else
            if [ "$FORCE_MODE" -eq 1 ] || confirm_action "Clean journal logs older than ${LOG_AGE_DAYS} days?"; then
                sudo journalctl --vacuum-time="${LOG_AGE_DAYS}d" >/dev/null 2>&1
                echo -e "   ${C_GREEN}✅ Journal cleaned${C_RESET}"
            fi
        fi
    fi
    
    # System log files
    local log_dirs=("/var/log" "$HOME/.local/share/logs" "$HOME/.cache")
    
    for log_dir in "${log_dirs[@]}"; do
        if [ -d "$log_dir" ] && [ -r "$log_dir" ]; then
            echo -e "${C_YELLOW}📝 Log Directory: $log_dir${C_RESET}"
            
            # Find old log files
            local old_logs
            old_logs=$(find "$log_dir" -name "*.log*" -o -name "*.old" -type f -mtime +$LOG_AGE_DAYS 2>/dev/null | wc -l)
            
            if [ "$old_logs" -gt 0 ]; then
                echo -e "   ${C_WHITE}Found ${C_YELLOW}$old_logs${C_WHITE} old log files${C_RESET}"
                
                if [ "$DRY_RUN" -eq 1 ]; then
                    echo -e "   ${C_DIM}[DRY RUN] Would remove $old_logs old log files${C_RESET}"
                else
                    if [ "$FORCE_MODE" -eq 1 ] || confirm_action "Remove old log files from $log_dir?"; then
                        find "$log_dir" -name "*.log*" -o -name "*.old" -type f -mtime +$LOG_AGE_DAYS -delete 2>/dev/null || true
                        echo -e "   ${C_GREEN}✅ Old log files removed${C_RESET}"
                    fi
                fi
            else
                echo -e "   ${C_GREEN}✅ No old log files to clean${C_RESET}"
            fi
        fi
    done
}

clean_docker() {
    echo -e "${C_BCYAN}🐳 DOCKER CLEANUP${C_RESET}"
    echo -e "${C_DIM}Cleaning the digital maritime fleet...${C_RESET}"
    echo ""
    
    if ! command -v docker >/dev/null 2>&1; then
        echo -e "${C_YELLOW}⚠️  Docker not found. Skipping Docker cleanup.${C_RESET}"
        return
    fi
    
    # Docker system info
    echo -e "${C_YELLOW}🐳 Docker Space Analysis:${C_RESET}"
    docker system df 2>/dev/null | while read -r line; do
        echo -e "   ${C_WHITE}$line${C_RESET}"
    done
    
    echo ""
    
    if [ "$DRY_RUN" -eq 1 ]; then
        echo -e "${C_DIM}[DRY RUN] Would perform Docker cleanup${C_RESET}"
        docker system df --verbose 2>/dev/null
    else
        if [ "$FORCE_MODE" -eq 1 ] || confirm_action "Perform Docker cleanup (remove unused containers, networks, images)?"; then
            echo -e "${C_PURPLE}🧹 Cleaning Docker system...${C_RESET}"
            docker system prune -f >/dev/null 2>&1 || true
            echo -e "${C_GREEN}✅ Docker cleanup completed${C_RESET}"
        fi
    fi
}

clean_temp_files() {
    echo -e "${C_BPURPLE}🗂️  TEMPORARY FILE CLEANUP${C_RESET}"
    echo -e "${C_DIM}Removing digital debris from temporary storage...${C_RESET}"
    echo ""
    
    local temp_dirs=("/tmp" "$HOME/.cache" "$HOME/.local/share/Trash" "/var/tmp")
    local total_cleaned=0
    
    for temp_dir in "${temp_dirs[@]}"; do
        if [ -d "$temp_dir" ] && [ -r "$temp_dir" ]; then
            echo -e "${C_YELLOW}🗑️  Processing: $temp_dir${C_RESET}"
            
            # Count old temporary files
            local old_files
            old_files=$(find "$temp_dir" -type f -mtime +$TEMP_AGE_DAYS 2>/dev/null | wc -l)
            
            if [ "$old_files" -gt 0 ]; then
                local temp_size
                temp_size=$(find "$temp_dir" -type f -mtime +$TEMP_AGE_DAYS -exec du -bc {} \; 2>/dev/null | tail -1 | cut -f1 || echo "0")
                
                echo -e "   ${C_WHITE}Found ${C_YELLOW}$old_files${C_WHITE} old files (${C_YELLOW}$(human_size "$temp_size")${C_WHITE})${C_RESET}"
                
                if [ "$DRY_RUN" -eq 1 ]; then
                    echo -e "   ${C_DIM}[DRY RUN] Would remove old temporary files${C_RESET}"
                else
                    if [ "$FORCE_MODE" -eq 1 ] || confirm_action "Remove old files from $temp_dir?"; then
                        find "$temp_dir" -type f -mtime +$TEMP_AGE_DAYS -delete 2>/dev/null || true
                        echo -e "   ${C_GREEN}✅ Old temporary files removed${C_RESET}"
                        total_cleaned=$((total_cleaned + temp_size))
                    fi
                fi
            else
                echo -e "   ${C_GREEN}✅ No old temporary files to clean${C_RESET}"
            fi
        fi
    done
    
    if [ "$total_cleaned" -gt 0 ]; then
        echo ""
        echo -e "${C_BGREEN}💰 Total space freed: $(human_size "$total_cleaned")${C_RESET}"
    fi
}

confirm_action() {
    local prompt="$1"
    
    if [ "$FORCE_MODE" -eq 1 ]; then
        return 0
    fi
    
    if [ "$SAFE_MODE" -eq 1 ]; then
        echo -ne "${C_YELLOW}🔍 $prompt${C_RESET} [${C_GREEN}y${C_RESET}/${C_RED}N${C_RESET}] "
        read -r response
        case "$response" in
            [yY]|[yY][eE][sS]) return 0 ;;
            *) return 1 ;;
        esac
    else
        echo -ne "${C_YELLOW}🔍 $prompt${C_RESET} [${C_GREEN}Y${C_RESET}/${C_RED}n${C_RESET}] "
        read -r response
        case "$response" in
            [nN]|[nN][oO]) return 1 ;;
            *) return 0 ;;
        esac
    fi
}

interactive_investigation() {
    echo -e "${C_BBLUE}🎛️  INTERACTIVE FORENSIC INVESTIGATION${C_RESET}"
    echo -e "${C_WHITE}Welcome to the Disk Space Detective's crime lab!${C_RESET}"
    echo ""
    
    while true; do
        echo -e "${C_CYAN}Choose your investigation:${C_RESET}"
        echo "  1) 🔍 Analyze directory usage"
        echo "  2) 🎯 Find large files"
        echo "  3) 🗑️  Clean package caches"
        echo "  4) 📋 Clean log files"
        echo "  5) 🐳 Clean Docker artifacts"
        echo "  6) 🗂️  Clean temporary files"
        echo "  7) 🧹 Complete cleanup (all of the above)"
        echo "  8) 🚪 Close case and exit"
        echo ""
        
        echo -ne "${C_YELLOW}Detective's choice${C_RESET} > "
        read -r choice
        
        case "$choice" in
            1|"analyze")
                echo -ne "${C_YELLOW}Enter directory to analyze${C_RESET} > "
                read -r target_dir
                if [ -n "$target_dir" ]; then
                    echo ""
                    analyze_directory "$target_dir"
                    echo ""
                fi
                ;;
            2|"large")
                echo -ne "${C_YELLOW}Enter minimum file size (e.g., 100M)${C_RESET} > "
                read -r file_size
                if [ -n "$file_size" ]; then
                    echo ""
                    find_large_files "$file_size"
                    echo ""
                fi
                ;;
            3|"cache")
                echo ""
                clean_package_caches
                echo ""
                ;;
            4|"logs")
                echo ""
                clean_logs
                echo ""
                ;;
            5|"docker")
                echo ""
                clean_docker
                echo ""
                ;;
            6|"temp")
                echo ""
                clean_temp_files
                echo ""
                ;;
            7|"all")
                echo ""
                echo -e "${C_BPURPLE}🧹 COMPLETE DIGITAL CLEANUP${C_RESET}"
                echo ""
                clean_package_caches
                echo ""
                clean_logs
                echo ""
                clean_docker
                echo ""
                clean_temp_files
                echo ""
                ;;
            8|"exit"|"quit"|"q"|"")
                echo -e "${C_GREEN}🎩 Case closed! The disk space mystery has been solved.${C_RESET}"
                break
                ;;
            *)
                echo -e "${C_RED}❌ Invalid choice. Try again, detective.${C_RESET}"
                ;;
        esac
    done
}

main() {
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -a|--analyze)
                OPERATION="analyze"
                TARGET_DIR="$2"
                shift 2
                ;;
            -l|--large)
                OPERATION="large"
                LARGE_FILE_SIZE="$2"
                shift 2
                ;;
            -c|--cache)
                OPERATION="cache"
                shift
                ;;
            -L|--logs)
                OPERATION="logs"
                shift
                ;;
            -d|--docker)
                OPERATION="docker"
                shift
                ;;
            -t|--temp)
                OPERATION="temp"
                shift
                ;;
            -s|--safe)
                SAFE_MODE=1
                shift
                ;;
            -f|--force)
                FORCE_MODE=1
                shift
                ;;
            -n|--dry-run)
                DRY_RUN=1
                shift
                ;;
            -q|--quiet)
                QUIET_MODE=1
                shift
                ;;
            -h|--help)
                print_usage
                exit 0
                ;;
            -v|--version)
                echo "Disk Space Detective 2000™ v$SCRIPT_VERSION"
                echo "by ShadowHarvy (Chief Digital Forensics Expert)"
                exit 0
                ;;
            -*)
                echo -e "${C_RED}❌ Unknown option: $1${C_RESET}" >&2
                echo -e "${C_YELLOW}💡 Try '$0 --help' for usage information${C_RESET}" >&2
                exit 2
                ;;
            *)
                echo -e "${C_RED}❌ Unexpected argument: $1${C_RESET}" >&2
                exit 2
                ;;
        esac
    done
    
    # Show banner (unless quiet)
    if [ "$QUIET_MODE" -eq 0 ]; then
        print_banner
        sleep 1
    fi
    
    # Execute operation
    case "$OPERATION" in
        "analyze")
            analyze_directory "$TARGET_DIR"
            ;;
        "large")
            find_large_files "$LARGE_FILE_SIZE"
            ;;
        "cache")
            clean_package_caches
            ;;
        "logs")
            clean_logs
            ;;
        "docker")
            clean_docker
            ;;
        "temp")
            clean_temp_files
            ;;
        *)
            # Default to interactive mode
            interactive_investigation
            ;;
    esac
    
    # Final flourish
    if [ "$QUIET_MODE" -eq 0 ] && [ "$OPERATION" != "" ]; then
        echo ""
        echo -e "${C_BGREEN}🕵️ Investigation complete! The evidence has been processed.${C_RESET}"
        echo -e "${C_DIM}\"The truth is out there... and now it's organized!\" - Disk Space Detective 2000™${C_RESET}"
    fi
}

# --- Script Entry Point ---
main "$@"