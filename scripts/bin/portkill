#!/usr/bin/env bash
# ===----------------------------------------===
#            Port Terminator 3000™
# ===----------------------------------------===
# Author: ShadowHarvy (Port Executioner Extraordinaire)
# Version: 1.0 (Now with extra dramatic flair!)
#
# Purpose: Finds and terminates processes hogging your precious ports.
#          Because sometimes ports need to learn who's boss, and
#          doing it manually is for people with too much time.
#
# Usage:
#   portkill [options] [port1] [port2] [port3...]
#   portkill                    # Interactive mode
#   portkill 8080               # Kill what's on port 8080
#   portkill 3000 5000 8080     # Kill multiple ports
#   portkill -f 80 443          # Force kill without asking
#
# Options:
#   -f, --force    Skip confirmation and terminate with extreme prejudice
#   -q, --quiet    Less theatrical output (but why would you want that?)
#   -h, --help     Show this help and exit
#   -v, --version  Show version information
#
# Exit Codes:
#   0 - Success (all ports cleared or nothing to kill)
#   1 - User chickened out
#   2 - Bad arguments or invalid port numbers
#   3 - Permission denied (try with sudo?)

# --- Strict Mode & Safety First ---
set -euo pipefail

# --- Script Configuration ---
SCRIPT_VERSION="1.0"
FORCE_MODE=0
QUIET_MODE=0
KILL_SIGNAL="TERM"  # Start gentle, escalate if needed

# --- Colors & Visual Flair ---
if [ -t 1 ]; then
    # Full color palette for maximum dramatic effect
    C_RESET='\033[0m'
    C_BOLD='\033[1m'
    C_DIM='\033[2m'
    C_RED='\033[0;31m'
    C_GREEN='\033[0;32m'
    C_YELLOW='\033[0;33m'
    C_BLUE='\033[0;34m'
    C_PURPLE='\033[0;35m'
    C_CYAN='\033[0;36m'
    C_WHITE='\033[0;37m'
    # Bright variants for extra pizzazz
    C_BRED='\033[1;31m'
    C_BGREEN='\033[1;32m'
    C_BYELLOW='\033[1;33m'
    C_BBLUE='\033[1;34m'
    C_BPURPLE='\033[1;35m'
    C_BCYAN='\033[1;36m'
    C_BWHITE='\033[1;37m'
else
    # Boring monochrome mode for the colorblind terminals
    C_RESET='' C_BOLD='' C_DIM='' C_RED='' C_GREEN='' C_YELLOW=''
    C_BLUE='' C_PURPLE='' C_CYAN='' C_WHITE='' C_BRED='' C_BGREEN=''
    C_BYELLOW='' C_BBLUE='' C_BPURPLE='' C_BCYAN='' C_BWHITE=''
fi

# --- Dramatic Functions ---

print_banner() {
    if [ "$QUIET_MODE" -eq 1 ]; then return; fi
    
    echo -e "${C_BCYAN}"
    echo "╔══════════════════════════════════════════════════╗"
    echo "║              ${C_BRED}PORT TERMINATOR 3000™${C_BCYAN}              ║"
    echo "║          ${C_WHITE}\"I'll be back... for your ports\"${C_BCYAN}          ║"
    echo "║                                                  ║"
    echo "║     ${C_BGREEN}by ShadowHarvy (Port Executioner)${C_BCYAN}        ║"
    echo "╚══════════════════════════════════════════════════╝"
    echo -e "${C_RESET}"
}

print_usage() {
    cat <<EOF
${C_BOLD}${C_BBLUE}Port Terminator 3000™ - Usage Guide${C_RESET}

${C_BOLD}SYNOPSIS${C_RESET}
    ${C_GREEN}portkill${C_RESET} [${C_YELLOW}options${C_RESET}] [${C_CYAN}port1 port2 port3...${C_RESET}]

${C_BOLD}DESCRIPTION${C_RESET}
    Finds and terminates processes that are hogging your precious ports.
    Because life's too short to manually hunt down rogue processes.

${C_BOLD}EXAMPLES${C_RESET}
    ${C_GREEN}portkill${C_RESET}                     ${C_DIM}# Interactive mode - asks what to kill${C_RESET}
    ${C_GREEN}portkill${C_RESET} ${C_CYAN}8080${C_RESET}                ${C_DIM}# Politely ask what's on 8080 to leave${C_RESET}
    ${C_GREEN}portkill${C_RESET} ${C_CYAN}3000 5000 8080${C_RESET}      ${C_DIM}# Multi-port elimination spree${C_RESET}
    ${C_GREEN}portkill${C_RESET} ${C_YELLOW}-f${C_RESET} ${C_CYAN}80 443${C_RESET}          ${C_DIM}# No mercy mode (skip confirmation)${C_RESET}
    ${C_GREEN}portkill${C_RESET} ${C_YELLOW}--quiet${C_RESET} ${C_CYAN}1337${C_RESET}        ${C_DIM}# Less theatrical, more business${C_RESET}

${C_BOLD}OPTIONS${C_RESET}
    ${C_YELLOW}-f, --force${C_RESET}    Skip confirmation and terminate with extreme prejudice
    ${C_YELLOW}-q, --quiet${C_RESET}    Reduce dramatic flair (but honestly, why would you?)
    ${C_YELLOW}-h, --help${C_RESET}     Show this help message and make a graceful exit
    ${C_YELLOW}-v, --version${C_RESET}  Display version info and credentials

${C_BOLD}EXIT CODES${C_RESET}
    ${C_GREEN}0${C_RESET}  Success (ports liberated or nothing needed killing)
    ${C_YELLOW}1${C_RESET}  User decided to spare the processes
    ${C_RED}2${C_RESET}  Invalid arguments or port numbers
    ${C_BRED}3${C_RESET}  Permission denied (maybe try with sudo?)

${C_BOLD}NOTES${C_RESET}
    - Port numbers must be between 1 and 65535 (basic networking, people!)
    - The script tries SIGTERM first, then escalates to SIGKILL if needed
    - Processes owned by root may require sudo privileges
    - Interactive mode shows you exactly what you're about to terminate

${C_DIM}Remember: With great port-killing power comes great responsibility.${C_RESET}
EOF
}

validate_port() {
    local port="$1"
    
    # Check if it's a number and within valid range
    if ! [[ "$port" =~ ^[0-9]+$ ]] || [ "$port" -lt 1 ] || [ "$port" -gt 65535 ]; then
        echo -e "${C_RED}❌ '$port' is not a valid port number. Try something between 1 and 65535.${C_RESET}" >&2
        return 1
    fi
    return 0
}

find_process_on_port() {
    local port="$1"
    local result=""
    
    # Try lsof first (more detailed output)
    if command -v lsof >/dev/null 2>&1; then
        result=$(lsof -i ":$port" -t 2>/dev/null || true)
    fi
    
    # Fallback to ss (more universally available)
    if [ -z "$result" ] && command -v ss >/dev/null 2>&1; then
        result=$(ss -tlnp | grep ":$port " | sed -n 's/.*pid=\([0-9]*\).*/\1/p' | head -1 || true)
    fi
    
    # Last resort: netstat (if available)
    if [ -z "$result" ] && command -v netstat >/dev/null 2>&1; then
        result=$(netstat -tlnp 2>/dev/null | grep ":$port " | awk '{print $7}' | cut -d'/' -f1 | head -1 || true)
    fi
    
    echo "$result"
}

get_process_info() {
    local pid="$1"
    local cmd user
    
    if [ ! -d "/proc/$pid" ]; then
        echo "Process $pid no longer exists"
        return 1
    fi
    
    # Get command line
    cmd=$(cat "/proc/$pid/cmdline" 2>/dev/null | tr '\0' ' ' || echo "unknown")
    if [ -z "$cmd" ] || [ "$cmd" = "unknown" ]; then
        cmd=$(ps -p "$pid" -o comm= 2>/dev/null || echo "unknown")
    fi
    
    # Get user
    user=$(ps -p "$pid" -o user= 2>/dev/null || echo "unknown")
    
    echo "$pid|$user|$cmd"
}

dramatic_pause() {
    if [ "$QUIET_MODE" -eq 1 ]; then return; fi
    
    local duration=${1:-1}
    sleep "$duration"
}

animate_search() {
    if [ "$QUIET_MODE" -eq 1 ]; then return; fi
    
    local port="$1"
    echo -ne "${C_YELLOW}Scanning port $port for unwanted squatters"
    for i in {1..5}; do
        echo -ne "."
        sleep 0.2
    done
    echo -e "${C_RESET}"
}

kill_process() {
    local pid="$1"
    local signal="${2:-TERM}"
    
    if ! kill -0 "$pid" 2>/dev/null; then
        echo -e "${C_YELLOW}⚠️  Process $pid has already vanished. Someone beat us to it!${C_RESET}"
        return 0
    fi
    
    if ! kill -s "$signal" "$pid" 2>/dev/null; then
        if [ "$signal" = "TERM" ]; then
            echo -e "${C_YELLOW}⚠️  Process $pid resisted termination. Escalating to SIGKILL...${C_RESET}"
            return $(kill_process "$pid" "KILL")
        else
            echo -e "${C_RED}❌ Failed to terminate process $pid. Permission denied?${C_RESET}"
            return 1
        fi
    fi
    
    # Give it a moment to die gracefully
    sleep 1
    
    if kill -0 "$pid" 2>/dev/null; then
        if [ "$signal" = "TERM" ]; then
            echo -e "${C_YELLOW}Process $pid is being stubborn. Bringing out the big guns...${C_RESET}"
            return $(kill_process "$pid" "KILL")
        else
            echo -e "${C_RED}❌ Process $pid refused to die. This is concerning.${C_RESET}"
            return 1
        fi
    fi
    
    return 0
}

process_port() {
    local port="$1"
    local pids
    
    if [ "$QUIET_MODE" -eq 0 ]; then
        animate_search "$port"
    fi
    
    pids=$(find_process_on_port "$port")
    
    if [ -z "$pids" ]; then
        echo -e "${C_GREEN}✅ Port $port is already free. Nothing to terminate here!${C_RESET}"
        return 0
    fi
    
    echo -e "${C_CYAN}🎯 Found processes on port $port:${C_RESET}"
    
    local killed_any=0
    for pid in $pids; do
        local info
        info=$(get_process_info "$pid")
        IFS='|' read -r pid_check user cmd <<< "$info"
        
        echo -e "   ${C_WHITE}PID: ${C_YELLOW}$pid${C_WHITE} | User: ${C_PURPLE}$user${C_WHITE} | Command: ${C_CYAN}$cmd${C_RESET}"
        
        local should_kill=1
        
        if [ "$FORCE_MODE" -eq 0 ]; then
            echo -ne "${C_BRED}💀 Terminate this process? ${C_RESET}[${C_GREEN}y${C_RESET}/${C_RED}N${C_RESET}] "
            read -r response
            case "$response" in
                [yY]|[yY][eE][sS]) should_kill=1 ;;
                *) should_kill=0 ;;
            esac
        fi
        
        if [ "$should_kill" -eq 1 ]; then
            echo -e "${C_PURPLE}⚡ Terminating process $pid...${C_RESET}"
            if kill_process "$pid"; then
                echo -e "${C_BGREEN}✨ Process $pid has been terminated successfully!${C_RESET}"
                killed_any=1
            else
                echo -e "${C_RED}💥 Failed to terminate process $pid${C_RESET}"
                if [ "$(id -u)" -ne 0 ] && [ "$user" = "root" ]; then
                    echo -e "${C_YELLOW}💡 Hint: Process is owned by root. Try running with sudo!${C_RESET}"
                    return 3
                fi
                return 1
            fi
        else
            echo -e "${C_YELLOW}😇 Process $pid has been spared. How merciful of you.${C_RESET}"
        fi
        dramatic_pause 0.5
    done
    
    return 0
}

interactive_mode() {
    echo -e "${C_BBLUE}🎮 Interactive Mode Activated!${C_RESET}"
    echo -e "${C_WHITE}Enter port numbers to scan (or 'quit' to exit):${C_RESET}"
    
    while true; do
        echo -ne "${C_CYAN}Port to scan${C_RESET} > "
        read -r input
        
        case "$input" in
            "quit"|"exit"|"q"|"")
                echo -e "${C_GREEN}👋 Farewell! May your ports remain unblocked.${C_RESET}"
                break
                ;;
            *)
                if validate_port "$input"; then
                    echo ""
                    process_port "$input"
                    echo ""
                fi
                ;;
        esac
    done
}

main() {
    local ports=()
    
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -f|--force)
                FORCE_MODE=1
                shift
                ;;
            -q|--quiet)
                QUIET_MODE=1
                shift
                ;;
            -h|--help)
                print_usage
                exit 0
                ;;
            -v|--version)
                echo "Port Terminator 3000™ v$SCRIPT_VERSION"
                echo "by ShadowHarvy (Port Executioner Extraordinaire)"
                exit 0
                ;;
            -*)
                echo -e "${C_RED}❌ Unknown option: $1${C_RESET}" >&2
                echo -e "${C_YELLOW}💡 Try '$0 --help' for usage information${C_RESET}" >&2
                exit 2
                ;;
            *)
                ports+=("$1")
                shift
                ;;
        esac
    done
    
    # Show the banner (unless we're in quiet mode)
    print_banner
    dramatic_pause 1
    
    # Validate all ports before starting
    for port in "${ports[@]}"; do
        if ! validate_port "$port"; then
            exit 2
        fi
    done
    
    # If no ports specified, go interactive
    if [ ${#ports[@]} -eq 0 ]; then
        interactive_mode
        exit 0
    fi
    
    # Process each port
    local overall_success=0
    for port in "${ports[@]}"; do
        echo ""
        if ! process_port "$port"; then
            overall_success=$?
        fi
    done
    
    # Final flourish
    if [ "$QUIET_MODE" -eq 0 ]; then
        echo ""
        if [ $overall_success -eq 0 ]; then
            echo -e "${C_BGREEN}🎉 Mission Accomplished! All targeted ports have been processed.${C_RESET}"
        else
            echo -e "${C_YELLOW}⚠️  Mission completed with some complications. Check the output above.${C_RESET}"
        fi
        echo -e "${C_DIM}\"Hasta la vista, baby!\" - Port Terminator 3000™${C_RESET}"
    fi
    
    exit $overall_success
}

# --- Script Entry Point ---
main "$@"