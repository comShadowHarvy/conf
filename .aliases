#!/usr/bin/env bash
# ============================================================================
#
#         Optimized & Refactored Shell Aliases and Functions
#
# ============================================================================

# ----------------------------------------------------------------------------
# General & Navigation Functions
# ----------------------------------------------------------------------------

# Create a directory and cd into it
mkcd() {
  [[ -z "$1" ]] && { echo "Usage: mkcd <directory>" >&2; return 1; }
  mkdir -p "$1" && cd "$1"
}

# Use fzf to interactively cd into a subdirectory
cdf() {
  local dir
  if command -v fd &>/dev/null; then
    dir=$(fd --type d --max-depth 2 | fzf --height 20% --reverse --prompt="Select directory > ")
  else
    dir=$(find . -maxdepth 2 -type d | fzf --height 20% --reverse --prompt="Select directory > ")
  fi
  # Only cd if a directory was selected
  [[ -n "$dir" ]] && cd "$dir"
}

# Go up a specified number of directories
up() {
  local d=""
  local limit="${1:-1}"
  # Ensure limit is a positive integer
  [[ ! "$limit" =~ ^[1-9][0-9]*$ ]] && limit=1
  for ((i=1; i<=limit; i++)); do
    d+="../"
  done
  # Use pushd/popd logic for safer navigation if available, else cd
  cd "$d" || echo "Error: Couldn't go up $limit level(s)." >&2
}

# Direct navigation aliases
alias ..="cd .."
alias ...="cd ../.."
alias ....="cd ../../.."
alias .....="cd ../../../.."
alias ~="cd ~"
alias dl="cd ~/Downloads"
alias dt="cd ~/Desktop"
alias p="cd ~/projects"
alias doc="cd ~/Documents"

# ----------------------------------------------------------------------------
# File & Directory Management
# ----------------------------------------------------------------------------

# Use modern, feature-rich tools if available, with robust fallbacks
if command -v eza &>/dev/null; then
  alias ls='eza --icons'
  alias ll='eza -al --icons --git'
  alias lt='eza --tree --level=2 --icons'
  alias la='eza -a --icons' # List all, including dots
  alias lm='eza -al --sort=modified --icons'
  alias lS='eza -al --sort=size --icons'
else
  # Colorized ls fallbacks (Note: 'la' and 'll' are identical)
  alias ls="ls --color=auto"
  alias ll="ls -alh --color=auto"
  alias la="ls -A --color=auto"
  alias l.="ls -ld .* --color=auto"
  alias lm="ls -alht --color=auto"
  alias lS="ls -alhS --color=auto"
fi

# Use rsync for cp/mv to get progress bars
alias ccp='rsync -avhP --info=progress2'
alias mmv='rsync -avhP --info=progress2 --remove-source-files'
alias mkdir='mkdir -pv'

# Use fd instead of find if it exists
command -v fd &>/dev/null && alias findr='fd'

# Find text in files, preferring ripgrep (rg)
ftext() {
  [[ $# -eq 0 ]] && { echo "Usage: ftext <pattern> [path]" >&2; return 1; }
  local pattern="$1"
  local path="${2:-.}"
  if command -v rg &>/dev/null; then
    rg --color=always --line-number --no-heading --smart-case "$pattern" "$path"
  else
    grep -rni --color=always "$pattern" "$path"
  fi
}

# Find directories by name, preferring fd
fdir() {
  [[ -z "$1" ]] && { echo "Usage: fdir <pattern> [depth]" >&2; return 1; }
  local pattern="$1"
  local depth="${2:-3}"
  if command -v fd &>/dev/null; then
    fd --type d --max-depth "$depth" --ignore-case "$pattern"
  else
    find . -maxdepth "$depth" -type d -iname "*$pattern*"
  fi
}

# Extract almost any archive format
extract() {
  [[ -z "$1" ]] && { echo "Usage: extract <archive_file>" >&2; return 1; }
  local file="$1"
  [[ ! -f "$file" ]] && { echo "Error: File '$file' not found." >&2; return 1; }

  echo "Extracting '$file'..."
  case "$file" in
    *.tar.bz2|*.tbz2|*.tbz) tar xjf "$file" ;;
    *.tar.gz|*.tgz)        tar xzf "$file" ;;
    *.tar.xz|*.txz)        tar xJf "$file" ;;
    *.tar|*.cbt)           tar xf "$file"  ;;
    *.zip|*.cbz|*.epub)    unzip "$file"   ;;
    *.rar|*.cbr)           unrar x "$file" ;;
    *.7z|*.cb7)            7z x "$file"    ;;
    *.gz)                  gunzip "$file"  ;;
    *.bz2)                 bunzip2 "$file" ;;
    *.xz)                  unxz "$file"    ;;
    *)
      echo "Error: Unsupported file type: '$file'" >&2
      return 1
      ;;
  esac
}

# **[FIXED]** Extract all archives in the current directory into their own subdirectories
extract-all() {
    for archive in *.tar.bz2 *.tbz2 *.tbz *.tar.gz *.tgz *.tar.xz *.txz *.tar *.cbt *.zip *.cbz *.epub *.rar *.cbr *.7z *.cb7 *.gz *.bz2 *.xz; do
        if [[ -f "$archive" ]]; then
            # Create a directory named after the archive, without the extension.
            # This handles complex extensions like .tar.gz
            local dest_dir
            dest_dir=$(basename "$archive" | sed -E 's/(\.tar\.(gz|bz2|xz)|.t(gz|bz2|xz))$//; s/\.[^.]+$//')
            
            mkdir -p -- "$dest_dir"
            echo "--- Extracting $archive to $dest_dir/ ---"
            # Use a subshell to extract into the new directory without changing the current shell's directory
            (cd -- "$dest_dir" && tar -xf "../$archive") || echo "Failed to extract $archive" >&2
        fi
    done
    echo "--- All archives processed. ---"
}


# ----------------------------------------------------------------------------
# Yazi File Manager
# ----------------------------------------------------------------------------
alias y='yazi'
ycd() {
  local tmp cwd
  tmp="$(mktemp -t "yazi-cwd.XXXXX")"
  # Ensure yazi is called with any arguments passed to ycd
  yazi --cwd-file="$tmp" "$@"
  if cwd="$(cat -- "$tmp")" && [[ -n "$cwd" && "$cwd" != "$PWD" ]]; then
    cd -- "$cwd"
  fi
  rm -f -- "$tmp"
}

# ----------------------------------------------------------------------------
# System Management
# ----------------------------------------------------------------------------

alias h='history'
alias j='jobs -l'
alias reload='exec "$SHELL" -l'
alias :q='exit'
alias please='sudo !!'

# System info and resource usage
alias psa='ps auxf'
alias psgrep='ps aux | grep -v grep | grep -i -e VSZ -e'
alias psmem='ps auxf | sort -nrk 4 | head -10'
alias pscpu='ps auxf | sort -nrk 3 | head -10'
alias meminfo='free -h'
alias cpuinfo='lscpu'
alias df='df -h'
alias du='du -h'
alias syswatch='watch -n 2 "echo \"## Memory Usage ##\"; free -h; echo; echo \"## Disk Usage ##\"; df -h -T /"'
alias tempcheck='sensors | grep -i "core"'

# Summarize directory contents
dirsummary() {
  local dir="${1:-.}"
  [[ ! -d "$dir" ]] && { echo "Error: Directory '$dir' not found." >&2; return 1; }
  echo "📂 Directory Summary for: $(realpath "$dir")"
  echo "───────────────────────────────────────"
  local files
  local dirs
  files=$(find "$dir" -type f | wc -l)
  dirs=$(find "$dir" -type d | wc -l)
  local size
  size=$(du -sh "$dir" | cut -f1)

  echo "📊 Stats:"
  printf "  Files: %'d, Directories: %'d, Total Size: %s\n" "$files" "$dirs" "$size"
  echo -e "\n📑 Top 5 File Types:"
  find "$dir" -type f -not -path '*/.*' -exec file {} + | sed 's/.*: //' | sort | uniq -c | sort -nr | head -5
  echo -e "\n📁 Top 5 Largest Subdirectories:"
  du -h --max-depth=1 "$dir" | sort -hr | head -n 6 | tail -n 5 # head -n 6 to include parent, tail -n 5 to exclude it
}

# Quick system overview
sysinfo() {
  echo "📊 System Information:"
  echo "  - Kernel: $(uname -rs)"
  echo "  - Uptime: $(uptime -p)"
  command -v free &>/dev/null && echo "  - Memory: $(free -h | awk '/^Mem:/ {printf "%s / %s (%s used)", $3, $2, $7}')"
  command -v df &>/dev/null && echo "  - Disk (/): $(df -h / | awk 'NR==2 {printf "%s / %s (%s used)", $3, $2, $5}')"
}

# ----------------------------------------------------------------------------
# Package Management (Arch Linux)
# ----------------------------------------------------------------------------

# Pacman
alias pacsyu='sudo pacman -Syu'
alias pacs='sudo pacman -S'
alias pacr='sudo pacman -Rns'
alias pacq='pacman -Q'
alias pacqs='pacman -Qs'
alias pacss='pacman -Ss'
alias pacsi='pacman -Si'
alias pacqi='pacman -Qi'
alias pacqo='pacman -Qo'
alias pacclean='sudo pacman -Scc' # Use with caution

# Paru (AUR Helper)
if command -v paru &>/dev/null; then
  alias parsua='paru -Sua --noconfirm'
  alias parsyu='paru -Syu --noconfirm'
  alias pars='paru' # Just use paru as the base command
  alias parr='paru -Rns'
  alias parqs='paru -Qs'
  alias parss='paru -Ss'
  alias parqi='paru -Qi'
fi

# **[SAFER]** Remove orphan packages
orphan() {
  local orphans
  orphans=$(pacman -Qtdq)
  if [[ -n "$orphans" ]]; then
    echo "The following orphan packages will be removed:"
    echo "$orphans"
    # shellcheck disable=SC2086
    sudo pacman -Rns $orphans
  else
    echo "No orphan packages to remove."
  fi
}
alias listorphan='pacman -Qtdq'

# Reflector (Mirrorlist)
alias mirror='sudo reflector --country Canada,US --age 6 --sort rate --save /etc/pacman.d/mirrorlist'

# ----------------------------------------------------------------------------
# Networking
# ----------------------------------------------------------------------------

alias ports='ss -tulanp' # ss is the modern replacement for netstat
alias lsport='sudo lsof -i'
alias myip="dig +short myip.opendns.com @resolver1.opendns.com"
alias localip="hostname -I | awk '{print \$1}'"
command -v vnstat &>/dev/null && alias vnstat="vnstat -i eth1"

# Nmap presets
alias nmap-open="nmap --open"
alias nmap-fast="nmap -F -T4 --version-light --top-ports 300"
alias nmap-full="sudo nmap -sS -A -v -T4 -p-" # Simplified full scan

# Simple HTTP server for sharing
share() {
  [[ ! -e "$1" ]] && { echo "Error: '$1' not found." >&2; return 1; }
  local port="${2:-8000}"
  local ip_addr
  ip_addr=$(hostname -I | awk '{print $1}')
  
  # Use a subshell to prevent directory changes and simplify cleanup
  (
    if [[ -d "$1" ]]; then
      cd "$1" || return
      echo "Sharing directory at http://$ip_addr:$port/"
    else
      # For files, serve from its containing directory to avoid copying
      local dir
      local file
      dir=$(dirname "$1")
      file=$(basename "$1")
      cd "$dir" || return
      echo "Sharing file at http://$ip_addr:$port/$file"
    fi
    python3 -m http.server "$port"
  )
}

# ----------------------------------------------------------------------------
# Media & Downloads
# ----------------------------------------------------------------------------

# Use yt-dlp if available, as it's more actively maintained
if command -v yt-dlp &>/dev/null; then
  alias ytmp3="yt-dlp --extract-audio --audio-format mp3 -o '%(title)s.%(ext)s'"
  alias ytmp4="yt-dlp -f 'bv[ext=mp4]+ba[ext=m4a]/b[ext=mp4]/best' -o '%(title)s.%(ext)s'"
else
  alias ytmp3="youtube-dl --extract-audio --audio-format mp3"
  alias ytmp4="youtube-dl -f 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/mp4'"
fi

alias wget='wget -c' # -c is sufficient; --no-hsts is rarely needed
alias get='wget -mpkc -R "index.html*"' # Mirror, page-requisites, convert-links

# ----------------------------------------------------------------------------
# Git & Development
# ----------------------------------------------------------------------------

alias gs="git status -sb" # Short branch status
alias ga="git add -A"
alias gc="git commit -m"
alias gca="git commit -am" # Stage and commit
alias gp="git push"
alias gpl="git pull"
alias gf="git fetch"
alias gco="git checkout"
alias gb="git branch"
alias glog="git log --graph --pretty='%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset'"
alias gclean="git clean -fd"
alias gclone="git clone"

# Function to clone a repo and cd into it
gcc() {
  [[ -z "$1" ]] && { echo "Usage: gcc <repo_url> [dir_name]" >&2; return 1; }
  local repo_url="$1"
  # Smartly derive directory name if not provided
  local dir_name="${2:-$(basename "$repo_url" .git)}"
  git clone "$repo_url" "$dir_name" && cd "$dir_name"
}

# Quickly add, commit, and push all changes
quickgit() {
  [[ -z "$1" ]] && { echo "Usage: quickgit <commit message>" >&2; return 1; }
  git rev-parse --is-inside-work-tree &>/dev/null || { echo "Error: Not a git repository." >&2; return 1; }

  git add -A && git commit -m "$*" && git push
}

# A robust git pull using rebase and handling stashing
gitupdate() {
  git rev-parse --is-inside-work-tree &>/dev/null || { echo "Error: Not a git repository." >&2; return 1; }
  
  local stashed=false
  # Only stash if there are uncommitted changes
  if ! git diff --quiet || ! git diff --cached --quiet; then
      echo "Stashing local changes..."
      git stash push -u # -u includes untracked files
      stashed=true
  fi

  echo "Fetching latest changes..."
  git fetch --all --prune || { $stashed && git stash pop; return 1; }

  local current_branch
  current_branch=$(git rev-parse --abbrev-ref HEAD)
  local upstream
  upstream=$(git rev-parse --abbrev-ref "@{u}" 2>/dev/null)

  if [[ -n "$upstream" ]]; then
    echo "Rebasing onto '$upstream'..."
    git rebase "$upstream" || { echo "Error: Rebase failed. Local changes remain stashed." >&2; $stashed && git stash pop; return 1; }
  else
    echo "No upstream branch configured for '$current_branch'. Skipping rebase."
  fi
  
  $stashed && echo "Applying stashed changes..." && git stash pop
  echo "✅ Update complete!"
}

# ----------------------------------------------------------------------------
# Tmux Shortcuts
# ----------------------------------------------------------------------------

alias ts='tmux new -s'
alias ta='tmux attach -t'
alias tl='tmux list-sessions'
alias tk='tmux kill-session -t'

# ----------------------------------------------------------------------------
# Shell, Apps, & Custom Commands
# ----------------------------------------------------------------------------

# Edit shell config files
alias reload-zsh="source \${ZDOTDIR:-\$HOME}/.zshrc"
alias edit-zsh="nvim \${ZDOTDIR:-\$HOME}/.zshrc"
alias edit-aliases="nvim \${ZDOTDIR:-\$HOME}/.aliases"

# Default Applications (Flatpak)
if command -v flatpak &>/dev/null; then
  alias vlc="flatpak run org.videolan.VLC"
  alias spotify="flatpak run com.spotify.Client"
  alias discord="flatpak run com.discordapp.Discord"
  alias teams="flatpak run com.microsoft.Teams"
  alias code="flatpak run com.visualstudio.code"
  alias studio="flatpak run com.visualstudio.code"
fi

# Use bat as a pager and for cat if available
if command -v bat &>/dev/null; then
  export MANPAGER="sh -c 'col -bx | bat -l man -p'"
  alias cat='bat -p'
fi

# Installer shortcuts
alias christitus='curl -fsSL christitus.com/linux | sh'
alias christitusdev='curl -fsSL https://christitus.com/linuxdev | sh'

pkg-install() {
  [[ -z "$1" ]] && { echo "Usage: pkg-install <package> [--verbose]" >&2; return 1; }
  [[ -f ~/install.sh ]] && ~/install.sh "$@" || { echo "Error: install.sh not found." >&2; return 1; }
}

# AI/Ollama Tools
alias ffabric='fabric --fast' # default to fast model
alias run_llama3='ollama run llama3:8b'

# Password generator
genpass() {
  local length="${1:-16}"
  [[ ! "$length" =~ ^[0-9]+$ || "$length" -lt 8 ]] && { echo "Specify a valid length (min 8)" >&2; return 1; }
  # Use a more robust character set and avoid special chars that cause issues in URLs/shells
  LC_ALL=C tr -dc 'A-Za-z0-9' < /dev/urandom | head -c "$length" ; echo
}

# Misc Tools & Fun
command -v lolcat &>/dev/null && {
  alias neofetch="neofetch | lolcat"
  alias loo="| lolcat"
}
alias lweather="ansiweather -l Palmerston,Ontario"
alias week="date +%V"
alias now="date +%T"
alias today='date "+%Y-%m-%d"'
alias tb="nc termbin.com 9999"
alias bc="bc -l"
alias sha1="openssl sha1"
alias sha256="openssl sha256"
alias md5="openssl md5"
alias flushmcd='echo "flush_all" | nc 10.10.27.11 11211'
alias jctl="journalctl -p 3 -xb"
alias gpg-check="gpg2 --keyserver-options auto-key-retrieve --verify"
alias gpg-retrieve="gpg2 --keyserver-options auto-key-retrieve --receive-keys"
